<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://greeng00se.github.io/</id>
    <title>GG Blog</title>
    <updated>2023-10-31T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://greeng00se.github.io/"/>
    <subtitle>GG Blog</subtitle>
    <icon>https://greeng00se.github.io/img/duck.png</icon>
    <entry>
        <title type="html"><![CDATA[레거시 코드 리팩터링 미션 회고]]></title>
        <id>https://greeng00se.github.io/refactoring-retrospective</id>
        <link href="https://greeng00se.github.io/refactoring-retrospective"/>
        <updated>2023-10-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1단계//github.com/woowacourse/jwp-refactoring/pull/465]]></summary>
        <content type="html"><![CDATA[<admonition title="PR 링크" type="note"><p>1단계: <a href="https://github.com/woowacourse/jwp-refactoring/pull/465">https://github.com/woowacourse/jwp-refactoring/pull/465</a><br>
<!-- -->2단계: <a href="https://github.com/woowacourse/jwp-refactoring/pull/547">https://github.com/woowacourse/jwp-refactoring/pull/547</a><br>
<!-- -->3단계: <a href="https://github.com/woowacourse/jwp-refactoring/pull/610">https://github.com/woowacourse/jwp-refactoring/pull/610</a><br>
<!-- -->4단계: <a href="https://github.com/woowacourse/jwp-refactoring/pull/721">https://github.com/woowacourse/jwp-refactoring/pull/721</a></p></admonition>
<h3 id="리팩터링-미션">리팩터링 미션</h3>
<p>요구사항 작성 → 테스트를 통한 코드 보호 → 리팩터링 → 의존성 리팩터링 → 멀티모듈 순서로 미션을 진행했다.<br>
<!-- -->미션에 온전히 집중하고 싶었지만, 프로젝트와 병행하면서 진행했기에 어느정도 타협보고 진행한 부분이 많아서 아쉬웠다.</p>
<h3 id="1-2단계">1, 2단계</h3>
<p>1단계는 요구사항을 작성하고, 테스트 코드를 작성하여 추후에 리팩터링 할 때 안정감 있게 진행할 수 있도록 준비하는 과정이었다.
요구사항을 작성할 때 제공된 용어 사전을 최대한 활용하면서 기존의 코드를 보면서 요구사항을 정리했다.
테스트는 시간 관계상 API, 서비스 둘 중 하나만 통합 테스트를 진행해야겠다는 생각이 들었다.</p>
<p>최종적으로 서비스 기준으로 통합 테스트를 작성했는데 약간 후회되는 결정이었던 것 같다.<br>
<!-- -->리팩터링 과정에서 API 명세가 바뀌지 않아야 한다는 것을 기준을 잡고 이번 미션을 한다고 가정했을 때 API 기준으로 테스트를 작성하고, 리팩터링을 진행하는 것이 더 안정감 있다고 생각한다.</p>
<p>2단계는 작성된 테스트 기반으로 리팩터링 하는 미션이었다.<br>
<!-- -->서비스에서 도메인을 직접 반환하는 구조였는데, 도메인에 JPA를 적용하면 기존 명세와 달라질 것을 우려해서 DTO로 수정하는 작업을 먼저 진행했다.
DTO 이후에 서비스에 있는 로직을 도메인으로 이동시키고, 최종적으로 JPA를 적용하는 순서로 리팩터링을 진행했다.
이 과정에서 의존성 방향이 양방향인 부분도 생겨났다.</p>
<h3 id="소프트웨어의-복잡성을-다루는-지혜">소프트웨어의 복잡성을 다루는 지혜</h3>
<p>중간에 소프트웨어 복잡성을 다루는 지혜에 관한 제이슨의 강의가 있었다.<br>
<!-- -->소프트웨어의 복잡성을 다루는 지혜는 에릭 에반스의 저서 <code>도메인 주도 설계</code>의 부제이다.</p>
<p>도메인 주도 설계는 유비쿼터스 언어, 전략적 설계, 전술적 설계가 중요하다고 한다.<br>
<!-- -->유비쿼터스 언어, 전략적 설계가 전체의 90%에 해당할 정도로 중요하다고 한다. 또한 전술적 설계만 하는 경우를 DDD Lite 라고 한다.</p>
<p>간단히 도메인 주도 설계에서 나오는 단어를 정리한다면 다음과 같다.</p>
<table><thead><tr><th>단어</th><th>설명</th></tr></thead><tbody><tr><td>도메인</td><td>소프트웨어로 해결하고자 하는 문제 영역</td></tr><tr><td>바운디드 컨텍스트</td><td>해결 영역, 관심사를 분리하고 격리하여 문제 해결에 집중할 범위</td></tr><tr><td>유비쿼터스 언어</td><td>프로젝트에 이해관계자들의 공통된 언어로, 서로의 의사소통 비용을 줄이기 위해 사용하는 언어</td></tr><tr><td>전략적 설계</td><td>도메인 전문가와 개발자가 함께 유비쿼터스 언어를 이용하여 도메인과 관련된 지식을 이해하고 이를 바탕으로 경계를 나눠 바운디드 컨텍스트를 정의하고, 컨텍스트 맵을 생성하는 것을 포함하는 과정</td></tr><tr><td>전술적 설계</td><td>전략적 설계에서 정의한 바운디드 컨텍스트와 도메인을 이용하여 애그리거트, Entity와 VO, Repository 등을 구현하는 과정</td></tr></tbody></table>
<p>이 외에도 다양한 내용들이 나왔지만, 지식을 제대로 흡수하지는 못했다.</p>
<h3 id="3-4단계">3, 4단계</h3>
<p>제이슨의 강의를 듣고, 조영호님의 우아한객체지향 유튜브 영상을 본 다음 3, 4단계를 진행했다.</p>
<p>3단계는 의존성 리팩터링에 관한 내용이었다. 클래스 간 방향, 패키지 간 방향을 단방향이 되도록 리팩터링을 진행해야 했었다.
함께 생성되고 삭제되는 객체들을 묶고, 결합도를 낮추기 위해 생명주기가 다르다면 id를 이용하여 참조하도록 변경했다.</p>
<p>의존성을 분리하기 위해 이벤트도 사용해보았다. 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 이벤트명은 과거 시제가 되어야하는 것을 알았다.
처음에는 애플리케이션 이벤트를 사용했지만, 서비스 로직을 최대한 간단하게 하기 위해 도메인 이벤트도 사용해보았다.</p>
<p>4단계는 멀티모듈로 분리하는 미션이었는데 3단계에서 분리해둔 패키지 그대로 분리하지는 않았다.<br>
<!-- -->3단계에서는 함께 생성되고 삭제되는 객체 기준으로 분리했다. 4단계에서는 내가 인식하기 편한 기준으로 분리를 했다.
아직 분리한 기준에 대한 근거가 모호했고, 이에 대한 공부를 조금 더 해야겠다고 생각했다.</p>
<mermaid value="graph LR
	subgraph Table
		OrderTable --> TableGroup
	end
	subgraph Order
		O
	end
  O[Order] --> OrderTable
	subgraph Menu
		M[Menu] --> MenuGroup
		M --> Product
	end
	O --> M"></mermaid>
<p>추가로 테스트 격리를 위한 직접 작성한 <code>@ServiceTest</code> 커스텀 애너테이션이 있었는데, 상위 모듈의 테스트에서 만든 클래스를 하위 모듈에서는 사용할 수 없었다.
따라서 TestFixtures를 사용하여 해결했다.</p>
<h3 id="마무리">마무리</h3>
<p>우아한테크코스의 마지막 미션이니 만큼, 가장 흥미로운 미션이었고 배울점도 많았던 것 같다.<br>
<!-- -->바쁜 기간이라 많은 리뷰를 남기지 못했던 리뷰이 호이에게 미안하고, 코멘트 꼼꼼하게 달아주고 미션에 대한 이야기도 오프라인으로 많이 나눈 리뷰어 테오에게 너무 감사하다.</p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://www.youtube.com/watch?v=kmUneexSxk0">도메인 원정대, 우아콘 2021</a><br>
<a href="https://www.youtube.com/watch?v=dJ5C4qRqAgA">우아한객체지향, 우아한테크세미나</a><br>
<a href="https://kwonnam.pe.kr/wiki/gradle/testfixtures">TestFixtures, 권남님</a></p>]]></content>
        <category label="Woowahan Techcourse" term="Woowahan Techcourse"/>
        <category label="Retrospective" term="Retrospective"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jdbc 라이브러리 구현 미션 회고]]></title>
        <id>https://greeng00se.github.io/jdbc-retrospective</id>
        <link href="https://greeng00se.github.io/jdbc-retrospective"/>
        <updated>2023-10-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1단계//github.com/woowacourse/jwp-dashboard-jdbc/pull/267]]></summary>
        <content type="html"><![CDATA[<admonition title="PR 링크" type="note"><p>1단계: <a href="https://github.com/woowacourse/jwp-dashboard-jdbc/pull/267">https://github.com/woowacourse/jwp-dashboard-jdbc/pull/267</a><br>
<!-- -->2단계: <a href="https://github.com/woowacourse/jwp-dashboard-jdbc/pull/358">https://github.com/woowacourse/jwp-dashboard-jdbc/pull/358</a><br>
<!-- -->3단계: <a href="https://github.com/woowacourse/jwp-dashboard-jdbc/pull/448">https://github.com/woowacourse/jwp-dashboard-jdbc/pull/448</a><br>
<!-- -->4단계: <a href="https://github.com/woowacourse/jwp-dashboard-jdbc/pull/515">https://github.com/woowacourse/jwp-dashboard-jdbc/pull/515</a></p></admonition>
<h3 id="jdbc-구현">Jdbc 구현</h3>
<p>이번 미션은 Jdbc 라이브러리를 구현하고, Transaction 경계 설정과 동기화하는 부분을 구현해 보는 미션이었다.<br>
<!-- -->미션 목표는 다음과 같다.</p>
<ul>
<li>JDBC 라이브러리를 구현하면서 중복을 제거하는 연습을 한다.</li>
<li>데이터베이스에 대한 이해도를 높인다.</li>
</ul>
<p>최대한 Java가 제공하는 기능을 사용하여 리팩터링 하는 방향으로 코드를 작성했다.</p>
<h3 id="jdbctemplate">JdbcTemplate</h3>
<p>JdbcTemplate은 Connection을 이용하여 PreparedStatement를 생성하는 부분, 그리고 PreparedStatement가 어떻게 동작하는지에 대한 부분을 분리했다.<br>
<!-- -->템플릿 콜백 패턴을 적절하게 적용하여 중복을 비교적 간단하게 제거할 수 있었다.<br>
<!-- -->예전에도 미션을 진행하면서 <a href="https://greeng00se.github.io/custom-jdbc-template">JdbcTemplate을 구현</a>한 적이 있었는데, 이번에는 자원 할당과 해제 부분에 대한 중복도 제거했다.</p>
<pre><code class="language-java">public class JdbcTemplate {

    private static final Logger log = LoggerFactory.getLogger(JdbcTemplate.class);

    private final DataSource dataSource;
    private final StatementCreator statementCreator;
    private final StatementExecutor statementExecutor;

    public JdbcTemplate(final DataSource dataSource) {
        this(dataSource, new StatementCreator(), new StatementExecutor());
    }

    JdbcTemplate(
            final DataSource dataSource,
            final StatementCreator statementCreator,
            final StatementExecutor statementExecutor
    ) {
        this.dataSource = dataSource;
        this.statementCreator = statementCreator;
        this.statementExecutor = statementExecutor;
    }

    private &lt;T&gt; T query(
            final String sql,
            final PreparedStatementCallback&lt;T&gt; preparedStatementCallback,
            final Object... parameters
    ) {
        final Connection connection = DataSourceUtils.getConnection(dataSource);
        try (final PreparedStatement preparedStatement = statementCreator.create(connection, sql, parameters)) {
            return preparedStatementCallback.execute(preparedStatement);
        } catch (final SQLException e) {
            log.error(e.getMessage(), e);
            throw new DataAccessException(e);
        } finally {
            DataSourceUtils.releaseConnection(connection, dataSource);
        }
    }

    public void update(final String sql, final Object... parameters) {
        query(sql, PreparedStatement::executeUpdate, parameters);
    }

    public &lt;T&gt; Optional&lt;T&gt; queryForObject(final String sql, final RowMapper&lt;T&gt; rowMapper, final Object... parameters) {
        final List&lt;T&gt; results = query(sql, statement -&gt; statementExecutor.execute(statement, rowMapper), parameters);
        if (results.size() &gt; 1) {
            throw new DataAccessException("2개 이상의 결과를 반환할 수 없습니다.");
        }
        return results.stream().findAny();
    }

    public &lt;T&gt; List&lt;T&gt; queryForList(final String sql, final RowMapper&lt;T&gt; rowMapper, final Object... parameters) {
        return query(sql, statement -&gt; statementExecutor.execute(statement, rowMapper), parameters);
    }
}
</code></pre>
<h3 id="트랜잭션-적용">트랜잭션 적용</h3>
<p>3, 4단계는 기존의 코드에 트랜잭션을 시작하고 끝나는 부분인 트랜잭션 경계를 설정하고 ThreadLocal을 이용하여 트랜잭션 동기화(Transaction synchronization)를 적용하는 미션이었다.<br>
<!-- -->트랜잭션 동기화란 트랜잭션을 시작하기 위한 Connection 객체를 ThreadLocal과 같은 공간에 따로 저장 후, 필요할 때 저장된 Connection을 가져다 사용하는 방식이다.<br>
<!-- -->아래와 같은 구조로 미션을 진행했는데, ThreadLocal에 Connection 객체가 아닌, Connection 객체와 Transaction이 진행 중인지 확인할 수 있는 flag를 가지고 있는 클래스를 저장해서 사용하도록 했다.</p>
<mermaid value="graph LR
	TransactionTemplate --> TransactionManager
	TransactionManager --> TransactionSynchronizationManager
	DataSourceUtils --> TransactionSynchronizationManager
	JdbcTemplate --> DataSourceUtils"></mermaid>
<h3 id="마무리">마무리</h3>
<p>Jdbc 미션을 진행하면서 AOP나 Transactional에 대한 학습 테스트도 진행하고, 약간 알찬 미션이었던 것 같다.<br>
<!-- -->꼼꼼히 코드를 봐준 리뷰어 호이 그리고 연휴 동안 계속 티키타카 하면서 재밌게 리뷰한 민트에게 감사하다.<br>
<!-- -->회고 이만 끝내고 리팩터링 미션 하러가야겠다. 😊</p>]]></content>
        <category label="Woowahan Techcourse" term="Woowahan Techcourse"/>
        <category label="Retrospective" term="Retrospective"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVC 구현 미션 회고]]></title>
        <id>https://greeng00se.github.io/mvc-retrospective</id>
        <link href="https://greeng00se.github.io/mvc-retrospective"/>
        <updated>2023-10-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1단계//github.com/woowacourse/jwp-dashboard-mvc/pull/404]]></summary>
        <content type="html"><![CDATA[<admonition title="PR 링크" type="note"><p>1단계: <a href="https://github.com/woowacourse/jwp-dashboard-mvc/pull/404">https://github.com/woowacourse/jwp-dashboard-mvc/pull/404</a><br>
<!-- -->2단계: <a href="https://github.com/woowacourse/jwp-dashboard-mvc/pull/465">https://github.com/woowacourse/jwp-dashboard-mvc/pull/465</a><br>
<!-- -->3단계: <a href="https://github.com/woowacourse/jwp-dashboard-mvc/pull/580">https://github.com/woowacourse/jwp-dashboard-mvc/pull/580</a></p></admonition>
<h3 id="mvc-구현">MVC 구현</h3>
<p>Reflection을 이용하여 Spring MVC와 유사한 기능을 구현하는 미션이었다.<br>
<!-- -->미션의 목표는 다음과 같았다.</p>
<ul>
<li>MVC 프레임워크를 구현하면서 내부 동작 원리를 학습한다.</li>
<li>점진적인 리팩토링을 경험한다.</li>
</ul>
<p>미션의 목표와 더불어 각 클래스들이 역할과 책임을 적절히 가지도록 하고, 패키지의 의존 방향을 고민하면서 미션을 진행하는 것에 중점을 두었다.</p>
<h3 id="애너테이션-기반-프레임워크-만들기">애너테이션 기반 프레임워크 만들기</h3>
<p>기존 코드에 ManualHandlerMapping이라는 서블릿을 직접 등록해서 사용하는 HandlerMapping 클래스가 있었고, 1단계에서는 애너테이션 기반의 AnnotationHandlerMapping을 구현해야 했기 때문에 @Controller, @RequestMapping을 Reflection을 이용하여 스캔하고, 핸들러 매핑을 등록하는 부분까지 진행해야 했다.<br>
<!-- -->테오가 @GetMapping이나 @PostMapping 부분도 진행하면 재밌을 것 같다고 해서 같이 진행해 보았다.<br>
<!-- -->추가로 미션 요구사항은 아니었지만 클래스 레벨에 적용된 @RequestMapping도 동작하도록 구현해보았다.</p>
<mermaid value="graph LR
    AHM[AnnotationHandlerMapping] --> AS[AnnotationScanner]
	AHM --> HKG[HandlerKeyGenerator] --> HMAP[HttpMappingAnnotationParser]"></mermaid>
<p>다음과 같은 Flow로 Handler(실제 요청을 처리하는 메서드) 등록을 진행한다.</p>
<ol>
<li>@Controller가 적용된 클래스의 정보를 스캔하여 반환한다.</li>
<li>@Controller가 적용된 클래스의 @RequestMapping이 적용된 메서드들의 정보를 반환한다.</li>
<li>각 메서드들을 순회하며 HandlerKey(uri + httpMethod 정보)와 HandlerExecution(인스턴스 + 실행하려는 메서드)을 생성하여 <code>Map&lt;HandlerKey, HandlerExecution&gt;</code>에 추가한다.</li>
</ol>
<p>AnnotationHandlerMapping의 initialize 메서드에서 Handler를 등록한다. 코드는 다음과 같다.</p>
<pre><code class="language-java" metastring="title=AnnotationHandlerMapping">public void initialize() {
    if (!initialized.compareAndSet(false, true)) {
        return;
    }

    final Map&lt;Class&lt;?&gt;, ControllerInstance&gt; controllers = annotationScanner.scanControllers();
    final Set&lt;Method&gt; methods = annotationScanner.scanHttpMappingMethods(controllers.keySet());
    for (final Method method : methods) {
        final ControllerInstance controller = controllers.get(method.getDeclaringClass());
        final HandlerExecution handlerExecution = new HandlerExecution(controller.getInstance(), method);
        final List&lt;HandlerKey&gt; handlerKeys = handlerKeyGenerator.generate(controller.getUriPrefix(), method);
        handlerKeys.forEach(handlerKey -&gt; handlerExecutions.put(handlerKey, handlerExecution));
    }

    log.info("Initialized AnnotationHandlerMapping!");
    handlerExecutions.keySet().forEach(key -&gt; log.info("key: {}, Handler: {}", key, handlerExecutions.get(key)));
}
</code></pre>
<h3 id="legacy-mvc와-mvc-통합">Legacy MVC와 @MVC 통합</h3>
<p>2단계는 Legacy MVC와 AnnotationHandlerMapping을 통합하는 부분이었다.<br>
<!-- -->기존의 MVC와 애너테이션이 적용된 MVC 두 개를 같이 사용할 수 있어야 헀다.<br>
<!-- -->대략적인 흐름은 다음과 같다.</p>
<ol>
<li>DispatcherServlet.service(request, response) 호출</li>
<li>HandlerMappings를 통해 입력받은 request에 해당하는 Handler 조회</li>
<li>HandlerAdapters를 통해 Handler를 실행시킬 수 있는 HandlerAdapter 조회</li>
<li>HandlerAdapter의.handle 메서드 실행</li>
<li>View의 render 호출</li>
</ol>
<mermaid value="graph LR
    D[DispatcherServlet]
    D --> HMS[HandlerMappings]
    D --> HAS[HandlerAdapters]

	HMS --> HandlerMapping
	subgraph HandlerMapping
		direction BT
		AHM[AnnotationHandlerMapping] --> HM[HandlerMapping]
		MHM[ManualHandlerMapping] --> HM
	end

	HAS --> HandlerAdapter
	subgraph HandlerAdapter
		direction BT
		HEHA[HandlerExecutionHandlerAdapter] --> HA[HandlerAdapter]
		CHA[ControllerHandlerAdapter] --> HA
	end"></mermaid>
<h3 id="웹-애플리케이션-발전-과정">웹 애플리케이션 발전 과정</h3>
<p>웹 애플리케이션의 발전 과정 대한 구구의 강의가 있었다.<br>
<!-- -->간단하게 정리하자면 다음과 같은 흐름으로 웹 애플리케이션이 발전했다.</p>
<mermaid value="graph LR
    WWW --> CGI(Common Gateway Interface) --> Servlet --> JSP --> MVC --> Framework --> Non-Blocking"></mermaid>
<p>내용이 길어져서 <a href="https://greeng00se.github.io/web-application-evolution">다음 문서</a>에 정리했다.</p>
<h3 id="추상적인-개념-학습-방법">추상적인 개념 학습 방법</h3>
<p>직관적이지 않은 추상적인 개념을 학습할 때는 개념의 구현을 참고하면 학습에 도움이 된다고 한다.</p>
<table><thead><tr><th>개념</th><th>구현</th></tr></thead><tbody><tr><td>OOP</td><td>Java</td></tr><tr><td>WAS</td><td>Tomcat, Jetty</td></tr><tr><td>IoC</td><td>Spring BeanFactory, Servlet Container, Framework</td></tr><tr><td>DI</td><td>Spring BeanFactory</td></tr></tbody></table>
<h3 id="정리">정리</h3>
<p>지금까지 스프링의 DispatcherServlet의 동작을 이론적으로만 알고 있었는데, 실제로 구현해 보니 조금 더 이해가 잘 가는 것 같다.<br>
<!-- -->이번 미션에서 나의 리뷰어는 루카, 리뷰이는 헤나였다.<br>
<!-- -->매 단계마다 꼼꼼하게 리뷰해 준 루카에게 너무 감사하고, 헤나에게 이상한 리뷰를 많이 남긴 것 같은데 꼼꼼히 반영해줘서 감사하다.<br>
<!-- -->오랫동안 기다려왔던 레벨 4 미션이 하나씩 마무리 될 때 마다 아쉬움이 남는다.</p>]]></content>
        <category label="Woowahan Techcourse" term="Woowahan Techcourse"/>
        <category label="Retrospective" term="Retrospective"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[스프링 테스트 격리]]></title>
        <id>https://greeng00se.github.io/spring-test-isolation</id>
        <link href="https://greeng00se.github.io/spring-test-isolation"/>
        <updated>2023-10-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[테스트 격리]]></summary>
        <content type="html"><![CDATA[<h3 id="테스트-격리">테스트 격리</h3>
<p>테스트의 순서에 따라 성공 실패 여부가 결정되는 비결정적인(non-determinism) 테스트가 되어서는 안되고, 테스트는 항상 순서에 상관없이 독립적으로 수행되도록 보장되어야 한다. 일반적으로 자원의 공유, 외부 API, 시간 등으로 비결정적인 테스트가 된다. 이를 해결하기 위해 테스트 대역을 사용하거나, 컨텍스트를 재실행하는 <code>@DirtiesContext</code>, 자원을 초기화하기 위해 테스트 이후에 테이블을 롤백 하는 <code>@Transactional</code>등 다양한 방법이 있다.<br>
<!-- -->해당 글에서는 스프링에서 데이터베이스 자원의 공유를 방지하기 위해 테스트 격리를 수행하는 부분에 대해 설명한다.</p>
<admonition title="Independent - FIRST" type="note"><p>테스트끼리 서로 의존하면 안 된다.<br>
<!-- -->서로 의존하게 된다면 하나의 테스트가 실패할 때, 또 다른 하나의 테스트가 실패할 수 있다.<br>
<!-- -->다른 테스트에 의존하지 않고, 독립적으로 실행 가능한 테스트가 좋은 테스트다.</p></admonition>
<h3 id="testexecutionlistener">TestExecutionListener</h3>
<p>스프링에서는 TextExecutionListner를 이용하여 각 테스트 실행 단계에서 이벤트를 수신할 수 있다.<br>
<!-- -->이를 이용하면 JUnit의 @BeforeEach를 사용하는 것과 유사하게, 테스트의 생명주기 이전 또는 이후에 필요한 작업을 실행시킬 수 있다.</p>
<pre><code class="language-java" metastring="title=TextExecutionListner">public interface TestExecutionListener {
    default void beforeTestClass(TestContext testContext) throws Exception {}
    default void prepareTestInstance(TestContext testContext) throws Exception {}
    default void beforeTestMethod(TestContext testContext) throws Exception {}
    default void beforeTestExecution(TestContext testContext) throws Exception {}
    default void afterTestExecution(TestContext testContext) throws Exception {}
    default void afterTestMethod(TestContext testContext) throws Exception {}
    default void afterTestClass(TestContext testContext) throws Exception {}
}
</code></pre>
<h3 id="abstracttestexecutionlistener-상속하여-구현">AbstractTestExecutionListener 상속하여 구현</h3>
<p>AbstractTestExecutionListener를 상속받아 테스트 격리 환경을 만들어주는 클래스로, 인터페이스인 TextExecutionListner와 달리 Ordered가 구현되어 있어 해당 클래스를 상속받아 구현한 클래스는 프레임워크가 제공하는 리스너 다음에 실행시키도록 해준다.<br>
<!-- -->다음과 같이 데이터베이스에서 각각의 테이블에 해당하는 Truncate 쿼리를 만들어서 조회하고, Test 메서드가 끝날때 마다 해당 쿼리를 실행하여 테이블을 초기화시키도록 설정한다.</p>
<pre><code class="language-java" metastring="title=DatabaseCleaner">
public class DatabaseCleaner extends AbstractTestExecutionListener {

    private static final String TRUNCATE_TABLE_QUERY = """
            SELECT Concat('TRUNCATE TABLE ', TABLE_NAME, ';') 
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_SCHEMA = 'PUBLIC'
            """;

    @Override
    public void afterTestMethod(TestContext testContext) {
        JdbcTemplate jdbcTemplate = getJdbcTemplate(testContext);
        List&lt;String&gt; truncateTableQueries = getTruncateTableQueries(jdbcTemplate);
        truncateTables(jdbcTemplate, truncateTableQueries);
    }

    private JdbcTemplate getJdbcTemplate(TestContext testContext) {
        return testContext.getApplicationContext().getBean(JdbcTemplate.class);
    }

    private List&lt;String&gt; getTruncateTableQueries(JdbcTemplate jdbcTemplate) {
        return jdbcTemplate.queryForList(TRUNCATE_TABLE_QUERY, String.class);
    }

    private void truncateTables(JdbcTemplate jdbcTemplate, List&lt;String&gt; truncateTableQueries) {
        jdbcTemplate.execute("SET REFERENTIAL_INTEGRITY FALSE");
        truncateTableQueries.forEach(jdbcTemplate::execute);
        jdbcTemplate.execute("SET REFERENTIAL_INTEGRITY TRUE");
    }
}

</code></pre>
<h3 id="listener-등록">Listener 등록</h3>
<p>@TestExecutionListeners를 이용하여 사용자 정의 리스너를 등록할 수 있다.<br>
<!-- -->mergeMode의 기본값은 REPLACE_DEFAULTS로 리스너가 이미 존재하는 경우 등록된 리스너로 변경된다.<br>
<!-- -->MERGE_WITH_DEFAULTS로 설정한다면 Ordered 기준으로 순서가 결정된다.<br>
<!-- -->이후 격리가 필요한 테스트들은 다음의 추상 클래스를 상속하여 사용하면 된다.</p>
<pre><code class="language-java" metastring="title=AcceptanceTest">
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestExecutionListeners(
        value = DatabaseCleaner.class,
        mergeMode = TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS
)
public abstract class AcceptanceTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    public void setUp() {
        RestAssured.port = port;
    }
}

</code></pre>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://www.baeldung.com/spring-testexecutionlistener">The Spring TestExecutionListener, Baeldung</a><br>
<a href="https://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/">인수테스트에서 테스트 격리하기, 테코블</a><br>
<a href="https://martinfowler.com/articles/nonDeterminism.html">Eradicating Non-Determinism in Tests, martin fowler</a><br>
<a href="https://mangkyu.tistory.com/264">@SpringBootTest의 테스트 격리시키기, MangKyu</a></p>]]></content>
        <category label="test" term="test"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[웹 애플리케이션 발전 과정]]></title>
        <id>https://greeng00se.github.io/web-application-evolution</id>
        <link href="https://greeng00se.github.io/web-application-evolution"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[웹 애플리케이션 발전 과정]]></summary>
        <content type="html"><![CDATA[<h3 id="웹-애플리케이션-발전-과정">웹 애플리케이션 발전 과정</h3>
<p>웹 애플리케이션의 발전 과정 대한 구구의 강의가 있었다.<br>
<!-- -->간단하게 정리하자면 다음과 같은 흐름으로 웹 애플리케이션이 발전했다.<br>
<!-- -->원래 회고에 작성하려고 했지만, 정리하다 보니 조금 길어져서 따로 분리했다.</p>
<mermaid value="graph LR
    WWW --> CGI(Common Gateway Interface) --> Servlet --> JSP --> MVC --> Framework --> Non-Blocking"></mermaid>
<h3 id="www1989">WWW(1989)</h3>
<p>정적 페이지를 제공하는 웹 서버를 시작으로 동적 페이지가 필요했기 때문에 CGI가 등장했다.</p>
<h3 id="cgi1993">CGI(1993)</h3>
<p>CGI는 동적 콘텐츠를 제공하기 위한 규약으로, 해당 인터페이스를 구현한 스크립트를 이용해서 매 요청마다 프로세스를 실행시켜 정보를 반환하도록 한다. 하지만 매 요청마다 프로세스를 실행시키기 때문에 서버에 많은 부하가 발생할 수 있다. 따라서 이러한 단점을 극복하기 위해 나온 것이 Servlet이다.</p>
<h3 id="servlet1996">Servlet(1996)</h3>
<p>Servlet은 웹 서버에서 실행되는 자바 프로그램으로 HTTP를 이용하여 웹 클라이언트의 요청을 수신하고 응답한다. CGI와 다르게 매 요청마다 프로세스가 아닌 스레드를 생성하여 응답한다.<br>
<!-- -->하지만 View 영역의 코드를 작성하기 위해 Servlet의 소스 코드를 알아야 하는 등 복잡도가 너무 높았다. 따라서 해당 문제를 해결하기 위해 JSP가 등장했다.</p>
<h3 id="jsp1999">JSP(1999)</h3>
<p>JSP는 HTML에 자바 코드를 작성하여 동적 웹 페이지를 생성하는 기술로, 유사한 기술로는 ASP, PHP가 있다.<br>
<!-- -->JSP만 사용하여 프로그래밍한다면 Model 1, 아래 구성도와 같이 JSP가 View 영역만 담당한다면 Model 2라고 한다.</p>
<mermaid value="---
title: JSP Model 2
---
graph LR
  Client -- Request --> Servlet <-- JDBC --> Database
	Servlet --> Bean
	Servlet --> JSP
	Bean <--> JSP
	JSP -- Response --> Client"></mermaid>
<h3 id="mvc2000">MVC(2000)</h3>
<p>위 JSP의 구성도를 보면 현재 MVC와 매우 유사한데, Govind Seshadri라는 사람이 JSP Model 2를 MVC 패턴으로 공식화를 제안했다.</p>
<blockquote>
<p>I provide an in-depth look at how you can gain optimal separation of presentation from content by using the JSP Model 2 architecture. This model can also be seen as a server-side implementation of the popular Model-View-Controller (MVC) design pattern.<br>
<!-- -->Govind Seshadri</p>
</blockquote>
<p>이때 MVC 패턴이 처음 탄생한 것은 아니고, 서버 측 구현이라고 하는 것을 보니 MVC가 처음 등장한 건 아닌 것 같다.<br>
<a href="https://folk.universitetetioslo.no/trygver/themes/mvc/mvc-index.html">해당 문서</a>를 보면 MVC라는 용어의 등장은 1978년에 등장한 것으로 보인다.</p>
<h3 id="spring-framework2003">Spring Framework(2003)</h3>
<p>Spring은 복잡했던 J2EE을 대체하기 위해 2003년에 등장했다.<br>
<!-- -->J2EE는 웹 기반의 엔터프라이즈 애플리케이션을 구축하기 위한 플랫폼으로 위에서 설명한 Servlet, JSP, EJB 등의 기술을 포함하고 있다.<br>
<!-- -->하지만 이중 EJB라는 기술이 J2EE의 핵심 기술이었는데, 해당 기술이 매우 복잡했기 때문에 사용에 문제가 많았다고 한다.<br>
<!-- -->2002년에 Rod Johnson이 EJB를 사용하지 않고 J2EE 애플리케이션을 구축하는 방법에 대해 저술한 <code>Expert One-to-One J2EE Development</code>라는 책을 발행했고, 출간 후 Juergen Hoeller, Yann Caroff가 Rod Johnson에게 오픈소스 제안을 하여 스프링이 탄생했다고 한다.</p>
<p>스프링은 엔터프라이즈 서비스 기능을 POJO에 제공하며, 이 덕분에 스프링을 사용하여 비즈니스 로직에 집중할 수 있다.</p>
<h3 id="webflux-이전-servlet-302009-312013">WebFlux 이전 Servlet 3.0(2009), 3.1(2013)</h3>
<p>Tomcat의 NIO 동작 방식을 보면 Poller가 소켓 커넥션을 들고 있다가 처리가 가능할 때 스레드를 할당하는 식으로 처리를 한다. 하지만 할당 후 Servlet과 통신하는 부분은 블로킹 방식으로 요청이 끝날 때까지 스레드를 점유하고 있었고, 스레드 점유로 인해 요청이 max thread에 도달하면 요청을 처리할 수 없었다.<br>
<!-- -->그래서 비동기 방식의 Servlet이 Servlet 3.0에 등장했다. 하지만 전통적인 I/O 방식을 사용하는 부분은 블로킹 방식으로 동작했다. Servlet 3.1에서 논블로킹 I/O가 추가되었지만, 많이 사용되지 않았다고 한다.</p>
<h3 id="spring-webflux2017">Spring WebFlux(2017)</h3>
<p>적은 수의 스레드로 동시성을 처리하고, 적은 리소스로 확장이 가능한 논블로킹 방식의 웹 기술이 필요했고, 기존의 Servlet의 경우 비동기를 지원한다 해도 동기식 API들이 많이 남아있었기 때문에 이러한 Servlet에 영향을 받지 않는 기술이 필요했다. 또한 기존에 Netty와 같이 비동기, 논블로킹 방식 서버로 자리를 잘 잡은 서버를 위해 Spring WebFlux가 등장했다.<br>
<!-- -->추가로 데이터 접근을 위해 사용하는 JDBC의 경우 Blocking API라, Spring Webflux에서는 R2DBC를 사용한다고 한다.</p>
<h3 id="마치며">마치며</h3>
<p>해당 정리 내용의 경우 Async, Non Blocking 관련된 내용을 깊게 공부한 적이 없어서 정확하지 않을 수 있다.<br>
<!-- -->그래도 기술의 등장 배경이나 과정을 알고 있다면 조금 더 깊이 있는 학습에 도움이 된다고 생각한다.</p>
<h3 id="참고-자료">참고 자료</h3>
<p>웹 애플리케이션의 발전 과정, 구구 강의<br>
<a href="https://httpd.apache.org/docs/trunk/en/howto/cgi.html">Dynamic Content with CGI, Apache Tutorial</a><br>
<a href="https://docs.spring.io/spring-framework/reference/overview.html#overview-history">History of Spring and the Spring Framework, Spring</a><br>
<a href="https://www.infoworld.com/article/2076557/understanding-javaserver-pages-model-2-architecture.html">Understanding JavaServer Pages Model 2 architecture, Govind Seshadri</a><br>
<a href="https://folk.universitetetioslo.no/trygver/themes/mvc/mvc-index.html">MVC, XEROX PARC</a><br>
<a href="https://www.amazon.com/Expert-One-One-Development-without/dp/0764558315">Expert One-to-One J2EE Development, Rod Johnson</a><br>
<a href="https://techblog.woowahan.com/2667/">배달의민족 최전방 시스템! ‘가게노출 시스템’을 소개합니다, 배달의민족</a><br>
<a href="https://www.infoworld.com/article/2077995/java-concurrency-asynchronous-processing-support-in-servlet-3-0.html">Asynchronous processing support in Servlet 3.0, Dr. Xinyu Liu</a>
<a href="https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html">WebFlux Overview, Spring</a>
<a href="https://d2.naver.com/helloworld/6080222">Spring WebFlux와 Armeria를 이용하여 Microservice에 필요한 Reactive + RPC 동시에 잡기, Naver D2</a><br>
<a href="https://tweety1121.tistory.com/entry/Spring-WebFlux-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C">Spring WebFlux란 무엇일까</a></p>]]></content>
        <category label="web application" term="web application"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[비동기 예외 로깅]]></title>
        <id>https://greeng00se.github.io/log-async-exception</id>
        <link href="https://greeng00se.github.io/log-async-exception"/>
        <updated>2023-09-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[문제 상황]]></summary>
        <content type="html"><![CDATA[<h3 id="문제-상황">문제 상황</h3>
<p>현재 트립드로우의 경로 이미지 생성 기능은 비동기로 처리되고 있다. 로그를 확인하는 도중 <code>@Async</code>가 적용된 메서드에서 예외가 발생하는 경우 로그가 정상적으로 출력되지 않는 문제가 발생했다.<br>
<!-- -->확인해 보니 Spring의 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>의 경우 동기 예외만 처리하고, 비동기 예외를 처리하지 않았기 때문에 발생한 문제였다.</p>
<h3 id="비동기-예외-발생시-로깅-설정">비동기 예외 발생시 로깅 설정</h3>
<p>스프링 4.1 부터 제공되는 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html">AsyncUncaughtExceptionHandler</a>의 경우 반환 타입이 void인 비동기 메서드를 예외 처리하기 쉽도록 도와준다.</p>
<p>따라서 AsyncUncaughtExceptionHandler 인터페이스를 구현해서 예외를 핸들링하는 클래스를 생성했다.<br>
<!-- -->기존의 동기 예외 처리의 경우 예외가 발생할 때 실행 흐름을 추적하기 위해 MDC(Mapped Diagnostic Context)를 사용하고 있다.<br>
<!-- -->비동기 예외 처리도 마찬가지로 MDC의 정보를 가져와서 로그를 출력하도록 설정했다.</p>
<pre><code class="language-java" metastring="title=AsyncExceptionHandler">@Slf4j
public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

    private static final String LOG_FORMAT = "[%s] %s";

    @Override
    public void handleUncaughtException(Throwable throwable, Method method, Object... obj) {
        log.info(String.format(LOG_FORMAT, MDC.get(REQUEST_ID.key()), throwable.getMessage()), throwable);
    }
}
</code></pre>
<p>AsyncExceptionHandler의 경우 AsyncConfigurer를 구현한 Configuration 클래스를 사용하여 등록할 수 있다.<br>
<!-- -->getAsyncUncaughtExceptionHandler() 메서드를 오버라이딩하여 AsyncExceptionHandler를 반환하도록 설정하면 된다.</p>
<pre><code class="language-java" metastring="title=AsyncConfig">@EnableAsync
@Configuration
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncExceptionHandler();
    }
}
</code></pre>
<p>이제 비동기 상황에서 예외가 발생하는 경우 AsyncUncaughtExceptionHandler의 구현체인 AsyncExceptionHandler가 예외를 잡아 처리한다.</p>
<h3 id="mdc-정보-연동-문제">MDC 정보 연동 문제</h3>
<p>비동기 처리의 경우 별도의 스레드에서 동작하기 때문에 ThreadLocal 기반으로 동작하는 MDC의 정보를 얻어올 수 없는 문제가 발생했다.</p>
<p><img alt="./mdc-null.png" src="https://greeng00se.github.io/assets/images/mdc-null-95b3bbdce99ef36ba843986413e0421a.png" width="2236" height="426"></p>
<p>스프링 4.3 이상부터 제공되는 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/task/TaskDecorator.html">TaskDecorator</a>를 이용하면 TaskExecutor를 커스터마이징 할 수 있다. TaskDecorator를 구현한 클래스를 하나 생성하고, Task가 실행되기 전 MDC의 정보를 복사하도록 설정한다.</p>
<pre><code class="language-java" metastring="title=MdcTaskDecorator">public class MdcTaskDecorator implements TaskDecorator {

    @Override
    public Runnable decorate(final Runnable runnable) {
        Map&lt;String, String&gt; threadContext = MDC.getCopyOfContextMap();
        return () -&gt; {
            MDC.setContextMap(threadContext);
            runnable.run();
        };
    }
}
</code></pre>
<p>생성한 Decorator 클래스를 설정 파일에 등록해 준다.</p>
<pre><code class="language-java" metastring="title=AsyncConfig">@RequiredArgsConstructor
@EnableAsync
@Configuration
public class AsyncConfig implements AsyncConfigurer {

    private final AsyncConfigurationProperties properties;

    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(properties.coreSize());
        executor.setMaxPoolSize(properties.maxSize());
        executor.setQueueCapacity(properties.queueCapacity());
        
        // highlight-next-line
        executor.setTaskDecorator(new MdcTaskDecorator());
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncExceptionHandler();
    }
}
</code></pre>
<p>설정 후에는 정상적으로 MDC에 들어가 있는 UUID가 출력되는 것을 볼 수 있다.</p>
<p><img alt="./mdc-not-null.png" src="https://greeng00se.github.io/assets/images/mdc-not-null-2b12c13f4f420a335c9e55dbea503f1b.png" width="2620" height="440"></p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://www.baeldung.com/spring-async">spring async, baeldung</a><br>
<a href="https://stackoverflow.com/questions/61885358/async-will-not-call-by-controlleradvice-for-global-exception">@Async will not call by @ControllerAdvice for global exception</a><br>
<a href="https://blog.gangnamunni.com/post/mdc-context-task-decorator/">Spring 의 동기, 비동기, 배치 처리시 항상 context 를 유지하고 로깅하기, 강남언니</a><br>
<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/task/TaskDecorator.html">TaskDecorator, Spring docs</a><br>
<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html">AsyncUncaughtExceptionHandler</a></p>]]></content>
        <category label="async" term="async"/>
        <category label="exception" term="exception"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[톰캣 구현 미션 회고]]></title>
        <id>https://greeng00se.github.io/tomcat-retrospective</id>
        <link href="https://greeng00se.github.io/tomcat-retrospective"/>
        <updated>2023-09-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1, 2단계//github.com/woowacourse/jwp-dashboard-http/pull/302]]></summary>
        <content type="html"><![CDATA[<admonition title="PR 링크" type="note"><p>1, 2단계: <a href="https://github.com/woowacourse/jwp-dashboard-http/pull/302">https://github.com/woowacourse/jwp-dashboard-http/pull/302</a><br>
<!-- -->3, 4단계: <a href="https://github.com/woowacourse/jwp-dashboard-http/pull/431">https://github.com/woowacourse/jwp-dashboard-http/pull/431</a></p></admonition>
<h3 id="톰캣-구현">톰캣 구현</h3>
<p>우아한테크코스를 지원할 때 객체지향과 관련된 미션도 기대를 많이 했지만 레벨 4에 진행하는 미션이 정말 하고 싶었다.<br>
<!-- -->그래서 미션을 할 수 있을까라는 걱정 반, 미션에 대한 기대 반으로 부푼 마음을 가지고 미션을 시작했던 것 같다.</p>
<p>이번 미션에서는 적절하게 추상화하고, 미션의 본질을 이해하려고 노력했다.<br>
<!-- -->톰캣 구현 미션은 <a href="https://datatracker.ietf.org/doc/html/rfc2616/">RFC 2616</a>에 명시된 스펙(완벽하지 않지만 미션에서 주어진 요구사항만 만족하도록)으로 요청을 받아 처리 후 반환하는데 집중했다.</p>
<h3 id="다이어그램">다이어그램</h3>
<p>Catalina는 Tomcat의 서블릿 컨테이너, Coyote는 HTTP 1.1 웹 서버를 지원하는 구성 요소라고 생각하고 아래와 같이 구성했다.<br>
<!-- -->사실 내부 구조를 깊게 공부할 시간을 가지지 못해서 각 구성 요소가 왜 해당 위치에 있는지 완벽하게 설명하지는 못하지만 미션을 진행하면서 이건 여기에 있으면 좋을 것 같은데? 라는 생각이 들면 적절한 패키지에 위치시키는 방향으로 진행을 했다.<br>
<!-- -->또한 적절하게 인터페이스를 사용하여 의존성 방향을 단방향으로 하려고 노력했다.</p>
<mermaid value="graph LR
	subgraph coyote
		HP[Http11Processor] --> A
		HP --> HttpRequestParser
		HP --> HttpResponseGenerator
		A[Adapter]
  end

  subgraph catalina
		RA[RequestAdapter] -.-> A
		AC[AbstractController] -.-> C[Controller]
		StaticController -.-> AC
		SM[SessionManger] -.-> Manager
		TC[Tomcat] --> RA
		RA --> C
		RA --> Manager
		RA --> RM
		RM[RequestMapper] --> C
  end

  subgraph jwp
		LC[LoginController] -.-> AC
		Application --> TC
  end
"></mermaid>
<h3 id="코드-리뷰">코드 리뷰</h3>
<p>크루 중 한 명이 나의 리뷰어가 되고, 내가 다른 크루의 리뷰어가 되는 형태로 진행이 되었다.<br>
<!-- -->나의 리뷰어는 디노, 리뷰이는 필립이었다.</p>
<p>디노(매의 눈이 아닌 공룡의 눈?)가 매우 꼼꼼하게 코드 리뷰를 해주어서 조금 더 나은 코드를 작성할 수 있었고, 필립의 코드에서는 꼼꼼하게 예외처리 하는 부분을 배울 수 있었다.<br>
<!-- -->한 가지 아쉬운 점은 필립에게 작성한 나의 코멘트들이 미션을 진행하면서 경험 기반으로 작성한 내용이 많아 근거가 조금 부족했고, 정리되지 않은 부분이 많았던 것 같다.<br>
<!-- -->다음 미션부터 리뷰할 때 조금 더 시간을 투자해서 더 좋은 내용을 크루들과 공유할 수 있도록 노력해야겠다.</p>
<h3 id="sessionconfig">SessionConfig</h3>
<p>미션을 진행 중 catalina 패키지의 Session 관련 부분을 보면서 중복 로직을 개선해 볼 수 있을 것 같아 <a href="https://github.com/apache/tomcat/pull/660">컨트리뷰트</a>를 시도했다.<br>
<!-- -->세션 쿠키의 이름을 가져오는 Util 클래스의 코드를 수정했는데 기본 값은 JSESSIONID 지만 설정에 따라서 세션 쿠키명을 다르게 사용할 수 있기 때문에 해당 로직이 있는 것으로 생각했다.<br>
<!-- -->기존의 코드는 명시된 주석의 내용과 코드의 흐름이 일치하지 않아서 약간 이해하기 어려웠다.</p>
<p>초기에 요청했던 PR은 기존의 코드보다 전체적으로 비교 연산을 한 번 줄일 수 있었고, context가 null인 경우 바로 기본 값을 반환함으로써 성능 개선의 효과가 있을 거라고 생각했다.<br>
<!-- -->메인테이너인 Mark Thomas 형이 해당 로직의 경우 컴파일러가 해당 부분을 최적화 할 수 있을 거라고 기대한다고 했고, 가독성을 개선시켜보라고 조언해주셨다.<br>
<!-- -->컴파일러 최적화는 고려해보지 못한 부분인데, 앞으로 학습해야 할 부분이 산더미라고 생각했다.</p>
<p>남겨준 코멘트에 따라 최종적으로는 중복된 코드를 줄이는 방향으로 코드를 수정했다.<br>
<!-- -->결과적으로 기존 로직 대비 비교 연산을 한 번 줄일 수 있었고, 명시된 주석의 내용과 유사한 흐름의 코드를 작성하여 좋은 방향으로 리팩터링을 했다고 생각한다.</p>
<!-- -->
<!-- -->
<div class="tabs-container tabList__CuJ"><ul role="tablist" aria-orientation="horizontal" class="tabs"><li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_LNqP tabs__item--active">기존</li><li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_LNqP">PR 요청</li><li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_LNqP">최종</li></ul><div class="margin-top--md"><div role="tabpanel" class="tabItem_Ymn6"><pre><code class="language-java">public static String getSessionCookieName(Context context) {

    String result = getConfiguredSessionCookieName(context);

    if (result == null) {
        result = DEFAULT_SESSION_COOKIE_NAME;
    }

    return result;
}

public static String getSessionUriParamName(Context context) {

    String result = getConfiguredSessionCookieName(context);

    if (result == null) {
        result = DEFAULT_SESSION_PARAMETER_NAME;
    }

    return result;
}

private static String getConfiguredSessionCookieName(Context context) {

    // Priority is:
    // 1. Cookie name defined in context
    // 2. Cookie name configured for app
    // 3. Default defined by spec
    if (context != null) {
        String cookieName = context.getSessionCookieName();
        if (cookieName != null &amp;&amp; cookieName.length() &gt; 0) {
            return cookieName;
        }

        SessionCookieConfig scc =
            context.getServletContext().getSessionCookieConfig();
        cookieName = scc.getName();
        if (cookieName != null &amp;&amp; cookieName.length() &gt; 0) {
            return cookieName;
        }
    }

    return null;
}
</code></pre></div><div role="tabpanel" class="tabItem_Ymn6" hidden=""><pre><code class="language-java">public static String getSessionCookieName(Context context) {
    if (context == null) {
        return DEFAULT_SESSION_COOKIE_NAME;
    }
    return getConfiguredSessionCookieName(context, DEFAULT_SESSION_COOKIE_NAME);
}

public static String getSessionUriParamName(Context context) {
    if (context == null) {
        return DEFAULT_SESSION_PARAMETER_NAME;
    }
    return getConfiguredSessionCookieName(context, DEFAULT_SESSION_PARAMETER_NAME);
}

private static String getConfiguredSessionCookieName(Context context, String defaultName) {
    // Priority is:
    // 1. Cookie name defined in context
    // 2. Cookie name configured for app
    // 3. Default defined by spec
    String cookieName = context.getSessionCookieName();
    if (cookieName != null &amp;&amp; cookieName.length() &gt; 0) {
        return cookieName;
    }

    SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig();
    cookieName = scc.getName();
    if (cookieName != null &amp;&amp; cookieName.length() &gt; 0) {
        return cookieName;
    }

    return defaultName;
}
</code></pre></div><div role="tabpanel" class="tabItem_Ymn6" hidden=""><pre><code class="language-java">public static String getSessionCookieName(Context context) {
    return getConfiguredSessionCookieName(context, DEFAULT_SESSION_COOKIE_NAME);
}

public static String getSessionUriParamName(Context context) {
    return getConfiguredSessionCookieName(context, DEFAULT_SESSION_PARAMETER_NAME);
}

private static String getConfiguredSessionCookieName(Context context, String defaultName) {
    // Priority is:
    // 1. Cookie name defined in context
    // 2. Cookie name configured for app
    // 3. Default defined by spec
    if (context != null) {
        String cookieName = context.getSessionCookieName();
        if (cookieName != null &amp;&amp; cookieName.length() &gt; 0) {
            return cookieName;
        }

        SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig();
        cookieName = scc.getName();
        if (cookieName != null &amp;&amp; cookieName.length() &gt; 0) {
            return cookieName;
        }
    }
    return defaultName;
}
</code></pre></div></div></div>
<h3 id="http-수업">HTTP 수업</h3>
<p>미션 중간에 진행되었던 HTTP 수업에는 HTTP를 적절하게 활용하는 부분에 대해 학습했다.<br>
<!-- -->항상 성능 개선을 위해 애플리케이션 단에서 최적화해보려고 노력을 했지만, 더 적은 시간을 투자해서 효율적으로 성능을 개선할 수 있는 방법에 대해 알 수 있었던 수업이었다.<br>
<!-- -->HTTP 압축, HTTP 캐싱, 리소스 최적화 기법에 대해 학습했다.</p>
<p>스프링 부트에서는 다음 옵션을 설정하여 http의 송수신의 압축을 진행할 수 있다.</p>
<pre><code class="language-yml">server:
  compression:
    enabled: true
</code></pre>
<p>수업 중 해당 압축 성능이 좋다면 왜 스프링 부트에서는 기본 값으로 설정을 하지 않았는지 궁금해졌다.<br>
<!-- -->궁금증을 해소하지 못했는데 말랑이 잡담 채널에 다음과 같은 <a href="https://github.com/spring-projects/spring-boot/issues/21369">issue</a>를 찾아주었다.<br>
<!-- -->내용을 요약해 보자면 WAS 별로 압축을 하기 위해 설정해야 하는 것이 다르고, 무조건 압축을 하는 것이 최적의 경우가 아닐 수 있기 때문에 기본값으로 설정하지 않는 것 같다.</p>
<blockquote>
<p>If you're developing a public-facing application then it's probably likely gzip compression would be worthwhile. If, however, you're a microservice application and you're in a dataceter, you may well prefer to reduce CPU load because you know you'll only be talking to other microservices and you have a reliable gigabit network.</p>
</blockquote>
<p>Phil Webb 형님의 말에 따르면 일반적인 애플리케이션을 개발하는 경우 gzip 압축을 사용하는 것이 좋지만, MSA 환경 + 데이터 센터에서 사용하는 경우 오직 다른 MSA 애플리케이션과 통신하고, 고성능 네트워크가 있기 때문에 CPU 부하를 줄이는 것이 우선시 될 수도 있다는 것이었다.</p>
<p>이외에도 의도하지 않은 캐싱을 막기 위해 휴리스틱 캐싱을 제거하거나, 개인 정보 유출을 막기 위해 응답 헤더에 private을 설정, ETag도 학습했다.</p>
<admonition title="ETag" type="note"><p>ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자다.<br>
<!-- -->웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐시가 더 효율적이게 된다.<br>
<!-- -->MDN</p></admonition>
<h3 id="thread-수업">Thread 수업</h3>
<p>스레드에 대한 수업을 들었지만, 복잡한 내용도 워낙 많았기 때문에 설명하라고 하면 잘 못할 것 같은 느낌이 든다.<br>
<!-- -->현재 프로젝트, 미션, 테코톡 준비를 병행해야 해서 세부적인 내용은 시간 날 때 복습하려고 한다.</p>
<p>스레드를 이해하고, WAS에 스레드 설정 관련한 실습이 있었는데 테오와 같이 1시간 정도 페어로 Thread 실습을 진행해 보았다.<br>
<!-- -->학습한 내용은 다음과 같다.</p>
<p><code>threads.max</code>: Tomcat의 최대 스레드 개수<br>
<code>max-connections</code>: Tomcat이 유지할 수 있는 최대 커넥션 개수<br>
<code>accept-count</code>: 최대 연결 수에 도달했을 때 연결 요청에 대해 운영 체제에서 제공하는 대기열의 최대 길이. 해당 Queue에 요청이 쌓이는 것은 Tomcat이 더 이상 요청을 받을 수 없다는 뜻이다. accpet-count queue에도 요청이 가득차면 그 이후에 오는 요청은 거부된다.</p>
<mermaid value="graph LR
    C(&quot;Client&quot;) -- request --> ACQ(&quot;운영체제에 의해 관리되는 Queue  
    size = accept-count&quot;) --> TCQ(&quot;Tomcat Connector에 의해 관리되는 Queue
    size = max-connections&quot;) --> TP(&quot;Thread Pool
    size = threads.max&quot;)"></mermaid>
<h3 id="마치며">마치며</h3>
<p>시간은 너무 빠르게 가고 할 일은 많은 것 같다.<br>
<!-- -->우선순위를 잘 정하고 학습을 진행해야겠다.<br>
<!-- -->현재 데이터 다루는 부분(DB)에 대한 학습이 많이 부족한 것 같다. 해당 부분은 테코톡이 끝나는대로 채워야겠다.</p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2616/">RFC 2616</a><br>
<a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag">ETag, mdn</a><br>
<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/http.html">Apache Tomcat 8 Configuration Reference</a><br>
<a href="https://bcho.tistory.com/788">Apache Tomcat Tuning, Terry Cho</a><br>
<a href="https://dev-ws.tistory.com/96">maxThreads, maxConnections, acceptCount로 Tomcat 튜닝하기</a></p>]]></content>
        <category label="Woowahan Techcourse" term="Woowahan Techcourse"/>
        <category label="Retrospective" term="Retrospective"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[성능 테스트 종류]]></title>
        <id>https://greeng00se.github.io/performance-test-type</id>
        <link href="https://greeng00se.github.io/performance-test-type"/>
        <updated>2023-09-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[성능 테스트]]></summary>
        <content type="html"><![CDATA[<h2 id="성능-테스트">성능 테스트</h2>
<p>API의 요청이 많은 상황에서 서버가 어떻게 동작하는지 확인하는 테스트</p>
<p>시스템에 부하가 걸리면 문제 상황이 발생할 수 있다.<br>
<!-- -->다양한 상황에 대비해서 성능 테스트를 해야한다.</p>
<p><img alt="./test.png" src="https://greeng00se.github.io/assets/images/test-355aba93f96ef7d6a0f3161bf6a9c25e.png" width="2168" height="1002"></p>
<h3 id="스모크-테스트smoke-test">스모크 테스트(Smoke Test)</h3>
<p>최소한의 부하를 주어 시스템이 정상적으로 동작하는지 확인하는 테스트</p>
<p>VU를 최소한으로 두고, 짧은 시간을 가지고 테스트한다.<br>
<!-- -->다른 테스트를 시작하기 전에 스모크 테스트를 함으로써 테스트 스크립트에 오류가 없는지 확인할 수 있고, 성능 지표가 정상적으로 수집, 모니터링 되고 있는지 확인할 수 있다.</p>
<admonition title="가상 사용자(VU)" type="note"><p>가상 사용자는 서버 애플리케이션에 대해 특정 테스트를 실행한다.<br>
<!-- -->이는 다른 가상 사용자와 독립적으로 실행되며, 여러 가상 사용자를 사용하여 동시 연결을 할 수 있다.<br>
<!-- -->스레드라고 생각하면 된다.</p></admonition>
<h3 id="스파이크-테스트spike-test">스파이크 테스트(Spike Test)</h3>
<p>사용량이 급증하는 상황에서 시스템이 견디고 성능에 문제가 없는지 확인하는 테스트</p>
<p>티켓 발급, 할인 쿠폰 발급과 같은 이벤트를 하는 경우 대규모 트래픽이 들어온다.<br>
<!-- -->스파이크 테스트를 통해 급증하는 부하 상황에서 시스템이 어떻게 동작하고, 부하를 잘 버티는지 확인할 수 있다.</p>
<h3 id="부하-테스트load-test">부하 테스트(Load Test)</h3>
<p>목푯값에 해당되는 부하를 견딜 수 있을지 확인하는 테스트</p>
<p>일반적인 부하 상황에서 시스템이 어떻게 동작하는지 확인하는 테스트다.<br>
<!-- -->램프업 또는 묙푯값에 해당하는 부하 기간동안 성능이 문제가 있는지 확인하고, 시스템 변경 후에도 부하 테스트를 돌려 동일하게 목푯값을 처리하는지 확인할 수 있다.</p>
<admonition title="램프 업(Ramp-up)" type="note"><p>부하 테스트를 위해 설정한 가상 사용자 수에 도달하는 데 걸리는 시간</p></admonition>
<h3 id="스트레스-테스트stress-test">스트레스 테스트(Stress Test)</h3>
<p>시스템의 최대치에 해당되는 부하를 받았을 때 시스템이 어떻게 동작하는지 확인하는 테스트</p>
<p>그래프를 봤을 때 부하 테스트와 유사한 형태로 보이지만, 부하량이 다르다.<br>
<!-- -->일반적으로 평균적인 목푯값 대비 작게는 50% 이상, 필요의 경우 그 이상으로 부하를 준다.<br>
<!-- -->스트레스 테스트는 부하 테스트를 실행한 후에만 실행해야 한다. 부하 테스트가 이루어지지 않은 상황에서 스트레스 테스트를 실행하는 경우에는 병목 지점이나 문제 상황을 찾기 어려워진다.<br>
<!-- -->또한 부하 테스트에서 사용한 스크립트를 VU값(스레드 수)만 수정하여 재사용하는 것이 좋다.</p>
<h3 id="내구-테스트endurance-test">내구 테스트(Endurance Test)</h3>
<p>평균 사용률로 일정 부하를 지속적으로 주며 시스템이 문제되는 지점을 확인하는 테스트</p>
<p>흡수 테스트(Soak Test)라고도 하며, 기본적인 부하 테스트의 변형이라고 볼 수 있다.<br>
<!-- -->다른 테스트와 달리 긴 시간동안 테스트를 하는 것이 특징이며, 메모리 누수 문제와 같이 장시간 애플리케이션을 실행할 때 시스템의 문제가 발생하는 부분을 확인하는 것이 목적이다.</p>
<h3 id="중단점-테스트breakpoint-test">중단점 테스트(Breakpoint Test)</h3>
<p>임계 지점을 찾기 위해 부하를 점진적으로 증가시키며 진행하는 테스트</p>
<p>문제되는 부분을 더 빨리 찾기 위해 다른 테스트를 통과한 다음에 중단점 테스트를 진행하고, 이 때 점진적으로 부하를 늘려나가는 것이 좋다.<br>
<!-- -->스트레스 테스트를 성능 튜닝과 반복해서 진행한다면, 시스템을 더욱 발전시킬 수 있다.<br>
<!-- -->다만 Auto Scaling이 적용된 클라우드 환경에서는 진행하지 않아야 한다.</p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://k6.io/docs/test-types/load-test-types/">Load test types, k6</a><br>
<!-- -->자바 최적화 - 벤저민 J. 에번스, 제임스 고프, 크리스 뉴랜드<br>
<!-- -->아마존 웹 서비스 부하 테스트 입문 - 나카가와 타루하치, 모리시타 켄</p>]]></content>
        <category label="performance test" term="performance test"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[DB 복제, @Transactional에 따라 요청 분리해보기]]></title>
        <id>https://greeng00se.github.io/db-replication</id>
        <link href="https://greeng00se.github.io/db-replication"/>
        <updated>2023-08-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[복제(Replication)]]></summary>
        <content type="html"><![CDATA[<h2 id="복제replication">복제(Replication)</h2>
<p>한 서버에서 다른 서버로 데이터를 동기화하는 것을 의미한다.<br>
<!-- -->원본 데이터를 가지는 서버를 Primary 또는 Source 라고 부르고, 복제된 데이터를 가지는 서버를 Secondary 또는 Replica 라고 부른다.</p>
<h3 id="복제를-하는-이유">복제를 하는 이유</h3>
<p><strong>1. 스케일 아웃</strong></p>
<p>사용자의 트래픽이 증가하는 경우, 데이터베이스에 가해지는 부하도 자연스럽게 증가한다.<br>
<!-- -->이를 처리하기 위해 복제를 통한 스케일 아웃을 적용하여 애플리케이션에서 사용하는 쿼리들을 각각의 데이터베이스로 분산 시킬 수 있다.</p>
<p><strong>2. 데이터 백업</strong></p>
<p>실제 운영되는 서비스가 사용하고 있는 DB에서 백업을 진행하는 경우, 서비스에 영향을 미칠 수 있다.<br>
<!-- -->따라서 실제 서비스에 영향이 가지 않도록 복제를 통해 Replica 서버를 구축하여, Replica 서버에서 복제를 진행하는 방법으로 영향을 최소화 할 수 있다.</p>
<p><strong>3. 데이터 분석</strong></p>
<p>백업과 마찬가지로 복잡하고 무거운 분석용 쿼리의 서비스에 영향을 미칠 수 있다.<br>
<!-- -->마찬가지로 복제를 사용해 분석용 쿼리를 사용할 수 있는 환경을 만들 수 있다.</p>
<p><strong>4. 데이터의 지리적 분산</strong></p>
<p>빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하거나, 고가용성(High Availability)을 위해서도 사용된다.</p>
<h3 id="바이너리-로그-파일-위치-기반-복제">바이너리 로그 파일 위치 기반 복제</h3>
<p>MySQL 서버에서 발생하는 변경사항에 대한 로그 파일을 바이너리 로그라고 한다.<br>
<!-- -->바이너리 로그를 통해 데이터 변경, 테이블 구조 변경, 계정이나 권한 변경에 대한 정보가 저장된다.<br>
<!-- -->MySQL의 복제는 바이너리 로그 기반으로 구현되어 있다. 이를 Replica 서버로 전달하고 바이너리 로그 기반으로 데이터를 변경 사항을 반영한다.</p>
<mermaid value="graph LR
	subgraph Replica
		direction TB
		IO[Replication I/O thread] -- save --> RL[Relay Log]
		SQL[Replication SQL Thread] -- read --> RL
	end

	subgraph Source
		direction TB
		BLD[Binary Log Dump Thread] -- Send Binary Log Dump--> IO
	end
"></mermaid>
<admonition title="스레드별 역할" type="note"><p>Binary Log Dump Thread: 바이너리 로그의 내용을 Replica 서버로 전달<br>
<!-- -->Replication I/O Thread: Binary 로그 이벤트를 가져와 로컬 서버의 파일(Relay Log)로 저장<br>
<!-- -->Replication SQL Thread: 릴레이 로그 파일의 이벤트를 읽고 실행</p></admonition>
<h3 id="바이너리-로그-방식의-문제점">바이너리 로그 방식의 문제점</h3>
<p>바이너리 로그 방식은 서버에 장애가 발생했을 때 복제 토폴로지 변경이 까다롭다.<br>
<!-- -->토폴로지란 네트워크의 요소들을 물리적으로 연결해 놓은 것, 또는 그 연결 방식을 말한다.</p>
<mermaid value="graph TD
	A[A binary-log:300] --> B[B Binary-log:300]
	A[A binary-log:300] --> C[C Binary-log:200]"></mermaid>
<p>위와 같이 Source 서버, Replica 2대가 존재하고, C 서버에 복제 지연이 되었을 때 문제가 발생한다.</p>
<mermaid value="graph TD
	A[A binary-log:300]
	B[B Binary-log:300] --> C[C Binary-log:200 문제 발생]"></mermaid>
<p>A 서버에서 장애가 발생한다면 B 서버를 Source 서버로 승격하고, C에게 조회 쿼리를 분산시킨다.<br>
<!-- -->하지만 여기서 C 서버에는 A 서버와 동기화가 안되었으니 조회 시 문제가 발생한다.<br>
<!-- -->뒤늦게 B 서버와 동기화를 하려고 해도, 어떤 바이너리 로그, 어떤 위치와 동기화해야하는지 알기 어렵다.</p>
<h3 id="글로벌-트랜잭션-아이디gtid-기반-복제">글로벌 트랜잭션 아이디(GTID) 기반 복제</h3>
<p>GTID 방식을 사용하여 참여한 모든 데이터베이스가 발생한 이벤트에 고유한 식별값을 부여한다면, 동기화에 대한 문제를 간단하게 해결할 수 있다.<br>
<!-- -->위의 예시와 같이 복제 지연과 함께 장애가 발생한다해도 특정 GTID 부터 복제를 재개하면 된다.</p>
<admonition title="GTID" type="note"><p>복제 토폴로지에 참여한 모든 서버에서 고유하도록 각 이벤트에 부여된 식별값<br>
<!-- -->[source_id]:[transaction_id]로 구성되며, source_id는 서버를 식별하기 위한 값이고 transaction_id는 커밋된 트랜잭션을 식별하기 위한 값으로 1씩 증가하는 형태로 발급된다.</p></admonition>
<h3 id="복제-토폴로지">복제 토폴로지</h3>
<p><strong>싱글 레플리카 복제 구성</strong></p>
<p>가장 간단한 구성으로 제일 많이 사용하는 형태다.<br>
<!-- -->replica 서버를 읽기 전용, 예비 서버, 백업 용도로 많이 사용한다.</p>
<mermaid value="graph LR
  W[Web Server] -- 읽기 + 쓰기 --> S
  W -- 읽기 --> R
  S[Source] --> R[Replica]"></mermaid>
<p><strong>멀티 레플리카 복제 구성</strong></p>
<p>2개의 replica 서버를 사용하는 형태다.<br>
<!-- -->하나의 replica는 예비 용도로 남겨두는 형태다.<br>
<!-- -->추후에 트래픽이 증가하는 경우 예비 용도의 replica를 사용함으로 읽기 요청의 부하 분산을 할 수 있다.</p>
<mermaid value="graph LR
  W[Web Server] -- 읽기 + 쓰기 --> S
  W -- 읽기 --> R1
  S[Source] --> R1[Replica1]
  S --> R2[Replica2]"></mermaid>
<p><strong>체인 복제 구성</strong></p>
<p>replica 서버가 많은 경우 바이너리 로그를 전달하는 작업 자체가 부하가 될 수 있다.<br>
<!-- -->따라서 1:M<!-- -->:M<!-- --> 구조로 체인 복제 구성을 고려할 수 있다.</p>
<mermaid value="graph LR
  W[Web Server] -- 읽기 + 쓰기 --> S
  W -- 읽기 --> R1
  S[Source] --> R1[Replica1]
  S --> R2[Replica2]
  S --> R3[Replica3]

  R3 --> R3-1[Replica 3-1]
  R3 --> R3-2[Replica 3-2]

  B[Batch Server] --> R3-2"></mermaid>
<p><strong>듀얼 소스 복제 구성</strong></p>
<p>2개의 MySQL 서버 모두 읽기와 쓰기가 가능하도록 하는 구성이다.<br>
<!-- -->각 서버에서 변경된 데이터는 다른 서버에 반영된다.<br>
<!-- -->목적에 따라 ACTIVE-ACTIVE 형태 또는 ACTIVE-PASSIVE 형태로 사용할 수 있다.<br>
<!-- -->ACTIVE-PASSIVE 형태인 경우 싱글 레플리카 복제 구성과 동일해보이지만, ACTIVE 서버에서 문제가 발생하면 설정의 변경없이 PASSIVE 서버로 쓰기 작업을 전환할 수 있다는 것이 장점이다.</p>
<mermaid value="graph LR
  W[Web Server] -- 읽기 + 쓰기 --> SR1
  W -- 읽기 + 쓰기 --> SR2
  SR1[Source/Replica 1] --> SR2[Source/Replica 2]"></mermaid>
<admonition title="ACTIVE-ACTIVE, ACTIVE-PASSIVE" type="note"><p>ACTIVE-ACTIVE: 2개의 서버 모두 쓰기 작업을 수행하는 형태<br>
<!-- -->ACTIVE-PASSIVE: 하나의 서버에서만 쓰기 작업을 수행하는 형태</p></admonition>
<p><strong>멀티 소스 복제 구성</strong></p>
<p>여러개의 source 서버와 하나의 replica 서버를 사용하는 구성이다.<br>
<!-- -->이는 source 서버의 데이터를 한 곳에 백업하는 용도로 사용, 여러 서버에 존재하는 데이터를 통합, 샤딩되어있는 테이블 데이터를 통합할 때 사용한다.</p>
<mermaid value="graph LR
  S1[Source 1] --> R[Replica]
  S2[Source 2] --> R"></mermaid>
<h2 id="바이너리-로그-방식-replication-구성하기">바이너리 로그 방식 Replication 구성하기</h2>
<p>mysql 2대를 이용하여 replication을 구성하고, spring boot application으로 source, replica 데이터베이스에 접근해보는 예제이다.<br>
<a href="https://github.com/bbiac/db-replication">https://github.com/bbiac/db-replication</a></p>
<h3 id="mysql-환경-구성">MySQL 환경 구성</h3>
<p>MySQL 버전은 8.1을 사용했다.<br>
<!-- -->13306, 13307 포트를 사용해서 MySQL 서버 2대를 띄웠다.<br>
<!-- -->또한 사실 IP 대역으로 통신할 수 있도록 커스텀 네트워크를 추가했다.</p>
<pre><code class="language-yml">version: '3.8'

services:
  source:
    platform: linux/x86_64
    image: mysql:latest
    restart: always
    container_name: mysql-source
    environment:
      TZ: 'Asia/Seoul'
      MYSQL_DATABASE: 'db'
      MYSQL_USER: 'user'
      MYSQL_PASSWORD: 'password'
      MYSQL_ROOT_PASSWORD: 'password'
    ports:
      - "13306:3306"
    volumes:
      - db-source:/var/lib/mysql
      - db-source:/var/lib/mysql-files
      - ./docker/source.cnf:/etc/mysql/my.cnf
    networks:
      - mysql_network

  replica:
    platform: linux/x86_64
    image: mysql:latest
    restart: always
    container_name: mysql-replica
    environment:
      TZ: 'Asia/Seoul'
      MYSQL_DATABASE: 'db'
      MYSQL_USER: 'user'
      MYSQL_PASSWORD: 'password'
      MYSQL_ROOT_PASSWORD: 'password'
    ports:
      - "13307:3306"
    volumes:
      - db-replica:/var/lib/mysql
      - db-replica:/var/lib/mysql-files
      - ./docker/replica.cnf:/etc/mysql/my.cnf
    networks:
      - mysql_network

volumes:
  db-source:
  db-replica:

networks:
  mysql_network:
    driver: bridge
</code></pre>
<p>또한 source, replica 각각 다음과 같이 db 설정을 했다.</p>
<table><thead><tr><th>설정</th><th>설명</th></tr></thead><tbody><tr><td>server_id</td><td>각각의 mysql 마다 고유한 값을 가져야 한다.</td></tr><tr><td>log_bin</td><td>바이너리 로그 파일 경로 설정으로 절대경로를 사용하지 않는다면 /var/lib/mysql 아래 해당 log_bin에 설정된 값으로 로그가 생성된다.</td></tr><tr><td>sync_binlog</td><td>N개의 트랜잭션 당 바이너리 로그를 디스크와 동기화 작업을 하도록 한다.&nbsp;1은 기본값으로 안정적이지만, 가장 느리다.</td></tr><tr><td>relay_log</td><td>릴레이 로그 파일 경로 설정</td></tr><tr><td>relay_log_purge</td><td>필요 없는 릴레이 로그 파일을 자동으로 삭제하는 옵션</td></tr><tr><td>read_only</td><td>읽기 전용 설정</td></tr><tr><td>log_replica_updates</td><td>Replication SQL Thread로 인해 실행되는 정보를 바이너리 로그에 기록  추후에 소스 서버로 승격되는 경우를 고려하면 설정하는 것이 좋다.</td></tr></tbody></table>
<!-- -->
<!-- -->
<div class="tabs-container tabList__CuJ"><ul role="tablist" aria-orientation="horizontal" class="tabs"><li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_LNqP tabs__item--active">Source</li><li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_LNqP">Replica</li></ul><div class="margin-top--md"><div role="tabpanel" class="tabItem_Ymn6"><pre><code class="language-cnf" metastring="title=&quot;/docker/source.cnf&quot;">[mysqld]
server_id=1
log_bin=mysql-bin
sync_binlog=1
</code></pre></div><div role="tabpanel" class="tabItem_Ymn6" hidden=""><pre><code class="language-cnf" metastring="title=&quot;/docker/replica.cnf&quot;">[mysqld]
server_id=2
relay_log=mysql-relay-bin
relay_log_purge=ON
read_only
log_replica_updates
</code></pre></div></div></div>
<h3 id="도커-실행">도커 실행</h3>
<p>docker-compose up 명령어로 docker-compose 설정으로 docker를 띄운다.<br>
<!-- -->-d 옵션을 붙이면 백그라운드 모드로 실행된다.</p>
<pre><code>docker-compose up -d
</code></pre>
<h3 id="replication-slave-권한-설정">replication slave 권한 설정</h3>
<p>REPLICATION SLAVE 권한이 설정되어 있어야 replica 서버에서 source 서버에 접근하여 로그를 읽어올 수 있다.<br>
<!-- -->source 서버에 접근하여 user 계정에 해당 권한을 설정해준다.</p>
<p>SOURCE 접속</p>
<pre><code class="language-bash">docker exec -it mysql-source mysql -u root -p
</code></pre>
<p>user 계정에 REPLICATION SLAVE 권한 추가</p>
<pre><code class="language-mysql">GRANT REPLICATION SLAVE ON *.* TO 'user'@'%';
FLUSH PRIVILEGES;
</code></pre>
<h3 id="source-db-정보-확인">SOURCE DB 정보 확인</h3>
<p>replica 설정에 필요한 source db의 바이너리 로그 파일명과 Position을 확인한다.<br>
<!-- -->Position 값은 실제 파일의 바이트 수를 의미한다.<br>
<!-- -->확인한 File(SOURCE_LOG_FILE)과 Position(SOURCE_LOG_POS) 값은 replica 설정에서 사용한다.</p>
<pre><code class="language-mysql">SHOW MASTER STATUS;

+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000003 |     1082 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
</code></pre>
<h3 id="source-ip-주소-확인">SOURCE ip 주소 확인</h3>
<p>docker inspect -f 옵션을 사용하면 해당 컨테이너의 세부 정보를 확인할 수 있다.<br>
<!-- -->다음 명령어를 이용해 docker-compose 파일에 설정해둔 mysql_network에서 사용되는 사설 아이피 주소를 확인한다.</p>
<pre><code class="language-bash">docker inspect -f "{{with index .NetworkSettings.Networks \"db-replication_mysql_network\"}}{{.IPAddress}}{{end}}" mysql-source
</code></pre>
<p>ip 주소가 나오지 않는 경우 docker inspect mysql-source로 확인한다.<br>
<!-- -->확인한 IP주소(SOURCE_HOST) 값은 replica 설정에서 사용한다.</p>
<h3 id="replica-mysql-접속">replica mysql 접속</h3>
<p>source db에 접속했던 방법과 동일하게 replica db에 접속한다.</p>
<pre><code class="language-bash">docker exec -it mysql-replica mysql -u root -p
</code></pre>
<h3 id="replica-설정">replica 설정</h3>
<p>이전에 source db에서 얻었던 정보들을 사용하여 replica 설정을 진행한다.<br>
<!-- -->실제 DB 서버에서 복제하는 경우 추가적으로 source DB의 파일을 복제해야하지만 현재 복제할 데이터가 없기 때문에 해당 부분은 생략했다.<br>
<!-- -->SOURCE_HOST, SOURCE_LOG_FILE, SOURCE_LOG_POS 를 적절히 변경한다.</p>
<pre><code class="language-mysql">STOP REPLICA;

CHANGE REPLICATION SOURCE TO 
SOURCE_HOST='172.29.0.2', 
SOURCE_USER='user', 
SOURCE_PASSWORD='password', 
SOURCE_LOG_FILE='mysql-bin.000001', 
SOURCE_LOG_POS=0, 
GET_SOURCE_PUBLIC_KEY=1;

START REPLICA;
</code></pre>
<h3 id="설정-확인">설정 확인</h3>
<pre><code class="language-mysql">SHOW REPLICA STATUS;

+----------------------------------+-------------+-------------+-------------+---------------+------------------+---------------------+------------------------+---------------+-----------------------+--------------------+---------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+---------------+----------------+----------------+-----------------------------+------------------+--------------------------------------+-------------------------+-----------+---------------------+----------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+------------------------+-----------------------+-------------------+
| Replica_IO_State                 | Source_Host | Source_User | Source_Port | Connect_Retry | Source_Log_File  | Read_Source_Log_Pos | Relay_Log_File         | Relay_Log_Pos | Relay_Source_Log_File | Replica_IO_Running | Replica_SQL_Running | Replicate_Do_DB | Replicate_Ignore_DB | Replicate_Do_Table | Replicate_Ignore_Table | Replicate_Wild_Do_Table | Replicate_Wild_Ignore_Table | Last_Errno | Last_Error | Skip_Counter | Exec_Source_Log_Pos | Relay_Log_Space | Until_Condition | Until_Log_File | Until_Log_Pos | Source_SSL_Allowed | Source_SSL_CA_File | Source_SSL_CA_Path | Source_SSL_Cert | Source_SSL_Cipher | Source_SSL_Key | Seconds_Behind_Source | Source_SSL_Verify_Server_Cert | Last_IO_Errno | Last_IO_Error | Last_SQL_Errno | Last_SQL_Error | Replicate_Ignore_Server_Ids | Source_Server_Id | Source_UUID                          | Source_Info_File        | SQL_Delay | SQL_Remaining_Delay | Replica_SQL_Running_State                                | Source_Retry_Count | Source_Bind | Last_IO_Error_Timestamp | Last_SQL_Error_Timestamp | Source_SSL_Crl | Source_SSL_Crlpath | Retrieved_Gtid_Set | Executed_Gtid_Set | Auto_Position | Replicate_Rewrite_DB | Channel_Name | Source_TLS_Version | Source_public_key_path | Get_Source_public_key | Network_Namespace |
+----------------------------------+-------------+-------------+-------------+---------------+------------------+---------------------+------------------------+---------------+-----------------------+--------------------+---------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+---------------+----------------+----------------+-----------------------------+------------------+--------------------------------------+-------------------------+-----------+---------------------+----------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+------------------------+-----------------------+-------------------+
| Waiting for source to send event | 172.25.0.3  | user        |        3306 |            60 | mysql-bin.000003 |                1082 | mysql-relay-bin.000002 |           868 | mysql-bin.000003      | Yes                | Yes                 |                 |                     |                    |                        |                         |                             |          0 |            |            0 |                1082 |            1078 | None            |                |             0 | No                 |                    |                    |                 |                   |                |                     0 | No                            |             0 |               |              0 |                |                             |                1 | 5a396b02-41c6-11ee-a56d-0242ac190003 | mysql.slave_master_info |         0 |                NULL | Replica has read all relay log; waiting for more updates |              86400 |             |                         |                          |                |                    |                    |                   |             0 |                      |              |                    |                        |                     1 |                   |
+----------------------------------+-------------+-------------+-------------+---------------+------------------+---------------------+------------------------+---------------+-----------------------+--------------------+---------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+---------------+----------------+----------------+-----------------------------+------------------+--------------------------------------+-------------------------+-----------+---------------------+----------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+------------------------+-----------------------+-------------------+
</code></pre>
<p>Replica_IO_Running, Replica_SQL_Running 값이 YES라면 정상적으로 replication 구성이 완료된 것이다.</p>
<p>설정을 마친 후 source db에 다음과 같이 create table 명령어를 입력한다.<br>
<!-- -->replica db에 동일한 member table이 생성된 것을 확인할 수 있다.</p>
<pre><code class="language-sql">CREATE TABLE member
(
    id   BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255)
);
</code></pre>
<h2 id="스프링-부트로-db-접근하기">스프링 부트로 DB 접근하기</h2>
<p>일반적인 트랜잭션의 경우 source, 읽기 전용 트랜잭션인 경우 replica로 요청이 가도록 구성해보자.</p>
<h3 id="environment-설정">Environment 설정</h3>
<p>다음과 같이 source, replica로 구분하여 설정한다.</p>
<pre><code class="language-yml" metastring="title=&quot;application.yml&quot;">spring:
  datasource:
    source:
      username: user
      password: password
      driver-class-name: com.mysql.cj.jdbc.Driver
      jdbc-url: jdbc:mysql://localhost:13306/db
    replica:
      username: user
      password: password
      driver-class-name: com.mysql.cj.jdbc.Driver
      jdbc-url: jdbc:mysql://localhost:13307/db
</code></pre>
<h3 id="datasourcetype-설정">DataSourceType 설정</h3>
<p>단순 문자열로도 구분할 수 있지만, enum을 이용해서 트랜잭션을 구분하도록 생성한다.<br>
<!-- -->Key는 추후에 빈 설정에 사용한다.</p>
<pre><code class="language-java" metastring="title=&quot;DataSourceType&quot;">public enum DataSourceType {
    SOURCE(SOURCE_NAME),
    REPLICA(REPLICA_NAME),
    ;

    private final String key;

    DataSourceType(String key) {
        this.key = key;
    }

    public static class Key {
        public static final String ROUTING_NAME = "ROUTING";
        public static final String SOURCE_NAME = "SOURCE";
        public static final String REPLICA_NAME = "REPLICA";
    }
}
</code></pre>
<h3 id="abstractroutingdatasource-설정">AbstractRoutingDataSource 설정</h3>
<p>스프링이 지원해주는 AbstractRoutingDataSource를 상속받아 트랜잭션의 읽기 여부에 따라 다른 DataSource를 향하도록 설정한다.</p>
<p>정적 팩터리 메서드는 <code>Map&lt;DataSourceKey, DataSource&gt;</code>에 해당하는 값을 받아 데이터 소스를 설정한다.</p>
<ul>
<li>setDefaultTargetDataSource: 기본 데이터 소스를 설정한다.</li>
<li>setTargetDataSources: 맵 형태로 받은 데이터 소스 값들을 설정한다.</li>
</ul>
<p>determineCurrentLookupKey를 오버라이딩하여 트랜잭션의 읽기 여부에 따라 다른 DataSourceType을 반환하도록 설정한다.</p>
<ul>
<li>isCurrentTransactionReadOnly() 메서드를 통해 트랜잭션이 읽기 전용인지 확인할 수 있다.</li>
<li>DataSourceType을 반환하도록 설정하고, 반환한 값에 해당하는 데이터 소스가 사용된다.</li>
</ul>
<pre><code class="language-java" metastring="title=&quot;RoutingDataSource&quot;">public class RoutingDataSource extends AbstractRoutingDataSource {

    private final Logger log = LoggerFactory.getLogger(getClass());

    public static RoutingDataSource from(Map&lt;Object, Object&gt; dataSources) {
        RoutingDataSource routingDataSource = new RoutingDataSource();
        routingDataSource.setDefaultTargetDataSource(dataSources.get(DataSourceType.SOURCE));
        routingDataSource.setTargetDataSources(dataSources);
        return routingDataSource;
    }

    @Override
    protected Object determineCurrentLookupKey() {
        boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();

        if (readOnly) {
            log.info("readOnly = true, request to replica");
            return DataSourceType.REPLICA;
        }
        log.info("readOnly = false, request to source");
        return DataSourceType.SOURCE;
    }
}
</code></pre>
<h3 id="datasource-설정">DataSource 설정</h3>
<p>위에서부터 순서대로 Source, Replica, RoutingDataSource, LazyConnectionDataSourceProxy 설정이다.<br>
<!-- -->스프링은 트랜잭션 시작시에 커넥션의 사용여부와 상관없이 커넥션을 확보한다.<br>
<!-- -->따라서 readOnly 트랜잭션이 설정된 메서드를 사용하더라도 미리 확보된 커넥션을 사용하기 때문에 replica db로 요청을 하지 않고 source db로 요청을 한다.</p>
<p>TransactionSynchronizationManager.isCurrentTransactionReadOnly() 메서드 호출 시 currentTransactionReadOnly라는 <code>ThreadLocal&lt;Boolean&gt;</code>에 설정된 값을 반환하는데 readOnly 설정이 되면 이 값을 true로 설정한다. 하지만 determineCurrentLookupKey를 호출하여 key 값을 가져오는 부분보다 이후에 설정되기 때문에 determineCurrentLookupKey 메서드에서 항상 DataSourceType.SOURCE가 반환되어 source db로 요청을 한다.</p>
<p>LazyConnectionDataSourceProxy를 설정하는 경우 실제 DataSource를 사용하는 시점에 커넥션을 획득해서 사용하기 때문에 설정한대로 replica db로 조회 요청을 한다.</p>
<pre><code class="language-java" metastring="title=&quot;DataSourceConfiguration&quot;">@Configuration
public class DataSourceConfiguration {

    @Bean
    @Qualifier(SOURCE_NAME)
    @ConfigurationProperties(prefix = "spring.datasource.source")
    public DataSource sourceDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Qualifier(REPLICA_NAME)
    @ConfigurationProperties(prefix = "spring.datasource.replica")
    public DataSource replicaDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Qualifier(ROUTING_NAME)
    public DataSource routingDataSource(
            @Qualifier(SOURCE_NAME) DataSource sourceDataSource,
            @Qualifier(REPLICA_NAME) DataSource replicaDataSource
    ) {
        return RoutingDataSource.from(Map.of(
                DataSourceType.SOURCE, sourceDataSource,
                DataSourceType.REPLICA, replicaDataSource
        ));
    }

    @Bean
    @Primary
    public DataSource dataSource(
            @Qualifier(ROUTING_NAME) DataSource routingDataSource
    ) {
        return new LazyConnectionDataSourceProxy(routingDataSource);
    }
}
</code></pre>
<p>최종적으로 DataSource 빈은 다음과 같은 형태가 된다.</p>
<mermaid value="graph LR
  DSP[LazyConnectionDataSourceProxy] --> RDS[RoutingDataSource]
	RDS --> S[SourceDataSource]
	RDS --> R[ReplicaDataSource]"></mermaid>
<h3 id="동작-확인">동작 확인</h3>
<p>간단하게 테스트를 작성해서 설정한대로 동작이 되는지 확인해보았다.<br>
<!-- -->save 메서드의 경우 <code>@Transactional</code>, findById 메서드의 경우 <code>@Transactional(readOnly = true)</code>가 설정되어있다.<br>
<!-- -->로그를 통해 save의 경우 source db로 findById의 경우 replica db로 요청을 하는 것을 알 수 있다.</p>
<pre><code class="language-java" metastring="title=&quot;MemberServiceTest&quot;">@SpringBootTest
class MemberServiceTest {

    @Autowired
    private MemberService memberService;

    @Test
    void 사용자를_저장한다() {
        // RoutingDataSource log: readOnly = false
        memberService.save("bbiac");
    }

    @Test
    void 사용자를_조회한다() {
        // RoutingDataSource log: readOnly = true
        assertThatThrownBy(() -&gt; memberService.findById(MAX_VALUE))
                .isInstanceOf(NoSuchElementException.class);
    }
}
</code></pre>
<p>DB에서는 확인하려면 root 계정으로 접속한 후 general log를 활성화 시킨다.</p>
<pre><code class="language-sql">SET GLOBAL log_output = 'table';
SET GLOBAL general_log = 1;
</code></pre>
<p>general log를 활성화 한 후 읽기 전용 메서드를 실행한다.<br>
<!-- -->server_id, 실행한 쿼리문을 확인할 수 있다.</p>
<pre><code class="language-sql">SELECT user_host, thread_id, server_id, convert(argument using utf8) FROM mysql.general_log where argument like '%select%';

+----------------------------+-----------+-----------+-----------------------------------------------------------------------------+
| user_host                  | thread_id | server_id | convert(argument using utf8)                                                |
+----------------------------+-----------+-----------+-----------------------------------------------------------------------------+
| user[user] @  [172.25.0.1] |       277 |         2 | select m1_0.id,m1_0.name from member m1_0 where m1_0.id=9223372036854775807 |
+----------------------------+-----------+-----------+-----------------------------------------------------------------------------+
</code></pre>
<p>확인 후 general log를 비활성화 한 후 비활성화 되었는지 확인한다.</p>
<pre><code class="language-sql">SET GLOBAL general_log = 0;
SHOW VARIABLES LIKE '%general%';

+------------------+---------------------------------+
| Variable_name    | Value                           |
+------------------+---------------------------------+
| general_log      | OFF                             |
| general_log_file | /var/lib/mysql/4b6b9db98290.log |
+------------------+---------------------------------+
</code></pre>
<h2 id="참고-자료">참고 자료</h2>
<p>16장 복제, Real MySQL 8.0 - 백은빈, 이성욱<br>
<a href="https://dev.mysql.com/doc/refman/8.1/en/replication.html">Replication, MySQL Docs</a><br>
<a href="https://huisam.tistory.com/entry/mysql-replication">MySql - Master Slave Replication 구조 만들어보기</a><br>
<a href="https://cheese10yun.github.io/spring-transaction/">Spring 레플리케이션 트랜잭션 처리 방식</a><br>
<a href="https://github.com/kwon37xi/replication-datasource">replication-datasource</a><br>
<a href="https://www.linkedin.com/pulse/simplified-guide-mysql-replication-docker-compose-rakesh-shekhawat/">Simplified Guide to MySQL Replication with Docker Compose</a><br>
<a href="https://www.daleseo.com/dockerfile/">Dockerfile에서 자주 쓰이는 명령어</a><br>
<a href="https://dev.mysql.com/doc/refman/8.1/en/change-replication-source-to.html">CHANGE REPLICATION SOURCE TO Statement</a><br>
<a href="https://kwonnam.pe.kr/wiki/springframework/lazyconnectiondatasourceproxy">LazyConnectionDataSourceProxy</a><br>
<a href="https://hudi.blog/database-replication-with-springboot-and-mysql/">데이터베이스 레플리케이션을 통한 쿼리 성능 개선 (feat. Mysql, SpringBoot)</a><br>
<a href="https://chagokx2.tistory.com/100">부하 분산을 위한 MySQL Replication 구성 및 쿼리 요청 분기</a><br>
<a href="https://docs.docker.com/get-started/08_using_compose/">Use Docker Compose, Docker</a></p>]]></content>
        <category label="mysql" term="mysql"/>
        <category label="replication" term="replication"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[우아한테크코스 레벨 3 회고]]></title>
        <id>https://greeng00se.github.io/woowacourse-level3-retrospective</id>
        <link href="https://greeng00se.github.io/woowacourse-level3-retrospective"/>
        <updated>2023-08-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[회고]]></summary>
        <content type="html"><![CDATA[<h3 id="회고">회고</h3>
<p>지난 8주는 레벨 1, 2 때보다 5배 정도 빠르게 지나간 것 같은 느낌이 들었다.<br>
<!-- -->레벨 3에는 기술적인 부분에서도, 기술 외적인 부분에서도 부족함이 많이 보였던 것 같다.<br>
<!-- -->부족한 부분을 알았기에, 앞으로 더욱 성장할 수 있을 것 같다.<br>
<!-- -->내가 부족했던 부분을 팀원들이 잘 보충해 줘서 든든했다.</p>
<h3 id="아쉬운-점">아쉬운 점</h3>
<p><strong>문서화</strong></p>
<p>개인적으로는 기술 외적으로 학습한 부분을 잘 정리하지 못했다.<br>
<!-- -->프로젝트를 진행하면서 내가 한 부분을 조금 더 꼼꼼하게, 이해하기 쉽게 문서화를 했더라면 팀원들에게 더욱 도움이 되었을 텐데 이 부분에 시간을 조금 더 투자하지 못했던 부분에서 아쉬움이 많이 들었다.<br>
<!-- -->방학 기간 동안 문서화를 하지 못했던 부분을 개인 블로그 올리면서 조금 더 채워보려고 한다.</p>
<p><strong>내가 못하는 부분이라면 시간을 들이자</strong></p>
<p>잘 못하는 부분이라면 시간을 들여서라도 중간은 가도록 해야겠다는 생각이 많이 들었다.<br>
<!-- -->말을 하기 전에 정리해서 의견을 내는 것, 발표 준비, 감정 조절 등등
못하는 부분을 인지하고, 개선하자.</p>
<p><strong>컴포트 존 벗어나기</strong></p>
<p>조금 더 도전적으로 목표를 잡았으면 좋았을 것 같다.<br>
<!-- -->매번 근거를 가지고 기술을 도입하고, 코드를 작성하려고 노력했다.<br>
<!-- -->하지만 지속적으로 개선하려고 하는 부분이 다소 부족했다.</p>
<h3 id="좋았던-점">좋았던 점</h3>
<p><strong>좋았던 점도 문서화</strong></p>
<p><a href="https://tripdraw.blog/">팀 블로그</a>도 먼저 도입하자고 제안하고, 내가 했던 부분은 문서화를 꽤 많이 해서 팀원들과 공유할 수 있었다.<br>
<!-- -->백엔드 크루 4명이서 같이 한 부분에 대해서는 기능 구현한다고 문서화가 조금 미흡해서 보충을 해야겠다.</p>
<p><strong>내가 디자인한 트립드로우 로고</strong></p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAYAAADITjAqAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABauSURBVHgB7d1viF3lncDx59yJsZpWU6wxoqmjLthGS2vBP4u7dEqb7FIXVKIFX9Qa3xTqiyisfWeNyEKphWZgLesbxyqLi4m0wiprXHCWIlUD1bKaRljt1CjGfzSmjdaYzNn73Dg2f5wkk8w95/nd+/nANCaZ0HHM3O/8nuc551SpRYvHJhYvXLhgrJquR+sqfblK9WiqqtGPfns0AdC6uk7bq6qaSvX09jpVU52q/kOanp78y+703PbJ1dtTS6rUoI+DVU2Ppbq6IokUQHRT3QFksvua/vCuXbsnmwxaIwFb+s2JsbozsqZb8W680uIEwEDqxuzeHLM3N37nl6nP+hawj6atNd3Z8ybRAhg6U1Wdbk8f7pncNrl6KvXBvAdMuADYx1R33+ze7kR2e5pn8xqwpSvuu747Pt6W7G0BsL/eRLbt8evuTfNkXgK2dGxitD5uwUSq6rEEALP7ZbVrz83zsazYScfotBX3r5k+buRZ8QLgCFxZLxx5Nq/YpWN01BNY3us6fuFIXi68KQHAXFVp3RuPXXdzOkpHFbDekuHCkXxE8ssJAI5a9Vy1a/dVR7OkOOeAfRSvJ5KDGgDMj6nuvtjX5xqxOQVMvADokzlH7IgDJl4A9NmcInZEARMvABpyxBE7omP0Hx3YGE0A0F/dgWnBL/JJ98O942EDdtrK+36anDYEoDH1V44/vneZ1iGNHOo3exeaVelHCQCademn/+aqd3e+9IunZnuHWffA8r5XvsOGG/IC0JLt3f2wC2fbD5t1CbG77/VT8QKgRYvr4zsTs/3mJwbso3tUXZkAoE11NTbbfRM7n/z+6bCbZwDQhNykTzqVeFDAlqy83/O8ACjJ6KcWdg66cfx+hzhcsAxAobZ/sGvP2dsnV2+f+YX9J7DjRsaSeAFQnsUHTmH7BczeFwClqlO1Zt+ffxywJd+4P586HE0AUKbFS785MTbzk79OYCPTjs0DULS6M/LxFNY7xJGPJx6/cOSPCQDK9vFhjt4EtnBkwVgCgPItPmHh3mbtXUK0fAhAENNVGss/9gJWpeprCQAiqOsr8g+V/S8Aounug32286kF6SsJAALJ+2Cd1OmMJQAIZLqqR/Me2GgCgECqlL7cqevOWQkAAqmnuxNYnTx1GYBgqiovIdajCQCC6VSVCQyAcEY7CQACEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQlqQAPrkzCUnpi+edXI6adFx3X8+IZ104nHp5EULP/F93925K+1478P0p50fps1TO9KO3o/vJpiNgLUkf0FfPbYsrbjo9HTmqSf2vtCJ49U33+u9uD6+6fW0YXJrIqVLz/9cWj56Uvdtcbpk+Snz9nc6f57z5/vpzW/3wvbUC28nyKrTVt5XJxqVv7AfWHtZL1zEl19gv3fnM70X2WGS/x6vvGhp75uw5aN7p6ym5Ijlbx42bto2dJ93/krAGiZegym/oF679sk06PLf31VfW9ZdPfh8MasG+RuIiUdeSk9tfkfMhowlxIb1llbEa+Dk5bM8jeSJYNDsu9yd/z1Lk6e/O2/8au+fNz6zd0k3T2cMPgFr2DVjZyUG06ruVDJIAcvhWv2tc9INl5/b6PLgsVh58em9t1ffei+NP7jF/uSAE7CGfbG7yc1gWn72yWkQ5KXBNdec11smjCqvcuSpbM23vyBkA8weWMN+v/6KxOA6+5qHU1SDEK7Z5InslruedYJxwJjAYMhFXCqcqzyR5cNTeRIbX7/FYY8BIWAwxFaNLUs/vP5LAxuuA+XDKJeef4plxQEhYDCE8nLhnd+/sMhThf02sz92yfmnmsaCcy9EGDJ5qfCRH48NZbz2laex3jWZ7oITloDBkMjLhLdef0HvbViWDA8nT2O/umtFbw+QeCwhwhDIU8bdt1zcu+iXg/1w9d59wPH1LybiMIHBgMvRyktl4nVoN337C929sQsTcZjAYIDNxMuS4ZHJ18DlR77ka8byo10omwkMBpR4HZ18K6oHbr+sFzLKJmAwgMTr2OTP362rL0iUTcBgwMw8ske8jk1eTrQnVjYBgwEiXvMrRyzfH5IyCRgMiBwtD0udf/l04iDe4HgQCBgMiHyBsnj1R/7cugyhPAIGA+Cma0wJ/ZSn27t/cLGTiYURMAiu9xyvb9un6bc83eYHZFIOAYPg8r4Xzbjh8nPSiotOT5RBwCCwvHRo36tZP7nxQkuJhRAwCMrSYTvyfpilxDIIGARl6bA9eSlx2J+nVgIBg4DyQyktHbbLBc7tEzAIJi8drr7cAxjblicwU1i7BAyCyd/5m77K4F6J7RIwCCRPXy5YLkf+RuLqsWWJdggYBGLfpTyrfEPRGgGDebJjZ3+f4Gv6KpO9sPYIWMNefeu9xGDq939b01e5/Ldpx4JEozZPvWsDfkBtntqR+iXy9JUn0xz3P+3cvd+vf2bRgoG5w3uewPLdOXa8198pnP0JWMMemtyaVrqX2kAaf3BL6pdI3+HnYG2YfCU9vfmd3jdsr7556Mk0RywHIH9dXHL+KSmq1f90TvfvwIuJ5lSnrbyvTjTqP9b+XegvVA52zyMvpTvufT71Q56+fnXXilS6p154O42vf7H349HKqxM5ZvkWWdFWKvKU+ffffzzRnJFPn3vV2kSj8hd4vp+aB+TFl6eNf3v4/9KP/31z6pcVFy1NKy8ud2rfuGlbuv5ffp0mHn35mPcB8xJcntomHnk5vfbW+2n52Sf3vlYiyB9nnjrtczfHBNai/B1m/gL94uhJadmpi1IbzlhyQrp0ecwTVE9tfju99ub7qQ1b39rZXRp7Pz3+zOt93/f41c9WFDmN5BfqW+569pgmrsPZ+wyu88Ls/61bv8UyYoPsgbUovwDkt43dF8G2rBpbFjZgG554pbenOMjyclqJ8cp7XHdMPN/3eM9E8ndTO9Kt11+QSpe/lsaTgDXFMXoo2KoC7/KQp4wclSZP3OU9xstvmez7tXbHauY0Is0QMChUiUfn21wiy3tj1659sviIrbh4aaIZAgaFumR5WSdVS9jfyRH73p3PpJI5nNUcAYNCXTN2VipFXsIr5XBCPjTSr0sW5kPJJ0YHjYBBgfLyYSnXCuaDFKUFIwf16RfeSSXKh27sgzVDwKBAJd2t5drbnkwl+ue7flPsflj+BoT+EzAoUCkBy/tepV6Ymz+ufPF0ifK1nfSfgEFhSlk+zIF46Imyr7PLS4klTmEOcjRDwKAwpZw+zIc2Sr8tUo5XiVOYJ040Q8CgMKWcPuznLaLmU57CSmMPrBkCBgXJN4QtYflww+TWMDelzVNYaScSTWDNEDAoSCl7J4+3eH/Oo5Fv7FySKHfQj07AoCCl3IZo46ZgAStwudMU1n8CBgUp4ckAUfa+9pVvMcXwETAoRN74L2EJMWIM8j6YB0kOHwGDQpRy8WvUELT1cNPZOInYfwIGhSjl7hv54ZER5adkM1wEDArh7g0wNwIGBcjHrksJ2Ktv2ksiBgGDApi+jt2yUxelkvhGoP8EDApQyrO/MocPiELAoAB/u/zUVIqoD2Ms7REmjvX3n4BBAUp68T1jyQkpmjw1un3T8BEwaFlpL74R9+NMX8NJwKBlpb34Xnp++7ezmqtSrqGb4QBHMwQMWlbaxJNvQhttH6y06JrAmiFg0LISl+xWfX1ZiiLHq7Q7vwtYMwQMWlbiYzdKW5I7lFVj5cX2d7+PeTuuaAQMWlbiBJanmgh7YfkAzNVjn0+lMYE1Q8CgRcvPLvfE35przkulK/Vj9HyyZggYtOiMU8u95qr0KSxPriVOXxEfCBqVgEGLSr/mquQp7O4fXJxKZPpqjoBBi0oPWJ7AVn/rnFSaW6+/oMjDL9nTL7yTaIaAQYtOPnFhKt0PV3+pqKXEGy4/t/dWKhNYcwQMWlTaXThmc/ctFxdxl/q855Wnr1LleDmB2BwBg5bk+x9GuQFt/jgfWHtZqxHL8brzxgtTyRzgaJaAQUuiPXcr7znliLWxb5eXDEuPV/b4pm2J5ggYtCTic7dyxB65c6yxgx158rvz+xcWvWw4Iy8dmsCatSABrYj42JIZ+WDH8rMXp/H1W/p25/V8cCRPXaWeNjzQU04fNk7AoCWfWRT7y+/qsWW9t3seeSlNPPryvIUshytffxbtsS7jD25JNEvAoCWRJ7B9zRxr3zC5NT00+cpRLaPlpcIcwxUXnR7yeWT539npw+YJGLQkwjVgczEzke3Y+WHvBf3pzW+nzVM7ej/f8d6H+71vXhY8o/u2fPSkXrCix3x8/YuJ5gkYtCT6EuJs8jS18uLTe2/DwOGN9jiFCC2JcjiBQxt/0PTVFgGDFkS6iJnZ5elrQ3ffj3YIGLQg4jVgHOyWu55NtEfAoAXR7sLBwfKpS3tf7RIwgDnKJytd99U+AYMWlPwkZg7vnkdfct1XAQQMWmAJMa4cLicPyyBgAEcoLx1ee9uTiTIIGLTANWAx5TtuWDosh4ABHIF80+L8RjkEDFqw7NRFiTjse5VJwAAOIccr73sdeENi2idg0IJBvZHvIPrej5+x71UoAYMWuA9iDLf87Nm0eerdRJkEDOATrFu/JW14wo16SyZg0ALH6MuW4+XQRvkEDGAf4hWHgAF8RLxiETCAJF4ROcsLDbP/VZ477n3eXTYCEjBgaOWb8+anKm/c9HoiHgEDhlK+ODlfpOw6r7gEDBg6OVrusBGfgAFDZcPkK+mOiefd23AACBgwNBzWGCwCBgy8vFSYD2s89cLbicEhYMBA27hpW7rlX39jyXAACRg07MwlrgNrQj4iP77+RUuGA0zAoGEmgf7LS4V5ydApw8EmYNCwHX8WsH7KU9e6B7ckBp+AAQPB1DV8BAwIzV7X8BIwIKx8wvCOif81dQ0pAQPCcV0XmYABYeTlwolHX3ZIgx4BA0LIe1z5gZMuQ2CGgAFFc7qQ2QgYNMwL8ZHJ4cqnC+1zMRsBA4oiXBwpAQOKIFzMlYABrRIujpaAQQvyPtiZpw73XemFi2MlYECjNkxuTQ9NviJcHDMBA/pu5gLke/7zJddxMW8EDFrw2pvvD8US4uapd7vT1ta04YlXhIt5J2DAvLO/RRMEDFqw9a2d6ZJ0ShoklglpmoABx8S0RVsEDFoQfULJe1uPb9pm2qJVAgYtyMtt0eSPecPkK71wmbYogYBBC/60c3eKIEcrT1t5iXDz7981bVEUAYMWvLtzVypZnrDypOX4OyUTMGhBiVEQLaIRMGjBa2+9n9o2szwoWkQlYNCCHX9uJxY5WjlYv87T1jOvixahCRhhlTDFHK18N/qm7kj/6pvvpY2bXnd6kIEjYEPu6RfeSVHlU3GR5XsErrnmvDTf9l0azOHKAYNBJGBDLk8B+QXvpEXHpUjyJBF9+eueR15Kq8aWzcsUloM1cwjDcXeGhYDRu8bn1usvSJHk6SW6/I3Dtbc9mR64/bI5R2xmWXDz1A57WQyt6rSV99WJoXfr6gvSDd86N0Wwbv2WNP7gi2lQ5Hj95MavpkvOn/3mvjlYT29+p3f44unNb1sWhCRg7OPS8z/XW9JaPnpy70W1lGXFPKnkpc6ZJbJBPYiQP/8rLlqali1Z1Pv51jd3mrDgEAQMgJA6CQACEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAEISMABCEjAAQhIwAELKAZtKABDLdhMYAAFVU51UV1MJACKpp7d3qmr6DwkAAqk63Qmsnq6eSwAQSV3/oVNbQgQgmunpyc6uPbsnEwAE8pfd6bnO9snV25Oj9ABEUaWp3K69x+jr+uEEAAFUKU3mH3sBq6c7kwkAAqjqqjd09QKW98HqOm1PAFC493ftPbvRC1heS6yq+n8SABSsqtK9H53d+OvNfKvp6XUJAAo2s3zY++d9f2PJivv+2K3b4gQApanS1BuPXXf2zE/3u5lvp6rHEwAUqJpOt+/78/0C9pdd0+sc5gCgON3pK43smdz3l/YLWO/CMFMYAIWp6vrn2/5r9dS+v3bQ88DyFNYrHQCUoNukbRu/u/bAXz4oYL0j9QesMwJAW2ZrUjXbHzjtH+5/ItX1WAKA1lS/fGPjd676pN/pzPpHqt2rHegAoC11d1Gw6uy+ebbfnzVgebOsqi0lAtCOTp1uPvDgxr5GDvWHd778i6c+fc6Vn+2OY5cmAGhKVY2/sfG6Hx3qXTrpMD74cHptnarnEgA047dvPPadmw73TocNWO/asM7uqxytB6Dvuq2pOnuuPLJ3PUJL/3FitK5Hnujuqo0mAJhvOV7Vnq8fat9r/3efAxEDoC/mGK+9f2SORAyAeXUU8coOuwd2oN7x+u7/kYMdAMyD3x5NvLI5T2D7Om3Fz9elqlqTAGCuqmr8gw92r515wvKc/3g6RktX3Hf9dEo/9SBMAI5E7w4bVbr9jceuW5eOwTEHLOvti013uh9IdUUCgNnU1WQ1snv10SwZHmheAjYjT2N1J93mgAcA+8kHNabT7dsev+7eNE/mNWAzlq78+dq6qr4rZADDLS8XdlI9np81ebR7XbPpS8CyvKyY9oyMmcgAhk8/wzWjbwHb15JvTFzZGelcWafuVAbAQOodzkjdPa7p3ePb/nv1ZOqzRgI2Y/HYxOKFI2msF7Oq+prJDCC8qVTVD9e7pyd37UmT/Zq2PkmjATtQDtqnFqSvpE5nbLquzuqWe7Rb8MXdT8ZolRzLByjEVO9/62qqTnV+VuRv63rPVNPBOtD/A6oeNVega6lDAAAAAElFTkSuQmCC" width="100">
<p>트립드로우 로고를 만들었다.<br>
<!-- -->팀원들이 대표 색상(파란색)을 정해줬고, 주말 동안 신나게 로고 디자인을 했던 것 같다.<br>
<!-- -->아래의 D 부분은 유튜브 강의 들으면서 직접 만들어서 뿌듯하다.</p>
<p><strong>기술 선택의 이유</strong></p>
<p>기술의 학습 비용, 현재 구조에 적합한지, 실제 가지고 있는 리소스를 고려해서 기술 선택을 하고, 도입했던 부분이 좋았다.<br>
<!-- -->100% 좋은 선택일 순 없지만, 그래도 선택에 대한 근거가 존재한다면 확률을 높혀주는 것 같다.</p>
<h3 id="마치며">마치며</h3>
<p>플레이스토어에 앱이 올라가 있는 거 너무 신기하다.<br>
<!-- -->안드로이드 브레멘 음악대(멧돼지, 수달, 핑구), 그리고 백엔드 팀원들(체인저, 후추, 리오) 너무 고생이 많았다.</p>]]></content>
        <category label="Woowahan Techcourse" term="Woowahan Techcourse"/>
        <category label="Retrospective" term="Retrospective"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[CloudWatch를 이용한 로깅, 메트릭 모니터링 환경 구성]]></title>
        <id>https://greeng00se.github.io/cloudwatch</id>
        <link href="https://greeng00se.github.io/cloudwatch"/>
        <updated>2023-08-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[CloudWatch]]></summary>
        <content type="html"><![CDATA[<h2 id="cloudwatch">CloudWatch</h2>
<p>AWS 리소스와 애플리케이션의 지표와 로그에 대한 모니터링을 제공하는 서비스다.<br>
<!-- -->지표를 감시하여 알림을 보내는 기능도 제공한다.<br>
<!-- -->프리티어를 사용하지 않는 경우 대시보드당 3$/M 의 비용이 청구되고, 지표나 로그의 양에 따라 비용이 추가적으로 청구된다.<br>
<!-- -->요금 정보에 대한 자세한 정보는 <a href="https://aws.amazon.com/ko/cloudwatch/pricing/">다음 링크</a>에서 확인할 수 있다.</p>
<h2 id="cloudwatch-metrics">CloudWatch Metrics</h2>
<p>기본적으로 5분마다 지표에 대한 정보가 수집된다.<br>
<!-- -->세부 모니터링(Detailed Monitoring)을 활성화하면 1분마다 지표를 수집한다.<br>
<!-- -->대시보드에서 InstanceId로 검색하여 수집된 지표를 확인할 수 있다.</p>
<p><img alt="./cloudwatch1.png" src="https://greeng00se.github.io/assets/images/cloudwatch1-859296155df6c20d0846f1388022a86c.png" width="3214" height="1636"></p>
<p>CPUUtilization, NetworkIn, NetworkOut과 같은 기본적인 지표를 제공하고, 메모리, 디스크 공간과 같은 지표를 확인하려면 사용자 지정 지표를 설정해야 한다.</p>
<h2 id="cloudwatch-agent-설치">CloudWatch Agent 설치</h2>
<p>CloudWatch Agent 사용자 지정 지표와 로그를 수집할 수 있다.</p>
<h3 id="iam-역할-설정">IAM 역할 설정</h3>
<p>기본적으로 EC2 인스턴스가 CloudWatchAgentServerPolicy에 대한 권한이 있어야 한다.<br>
<!-- -->IAM → 역할에서 역할 생성을 클릭한다.</p>
<p><img alt="./cloudwatch2.png" src="https://greeng00se.github.io/assets/images/cloudwatch2-ca9c26868dec08ea7133e2774f49798a.png" width="2614" height="1602"></p>
<p>CloudWatchAgentServerPolicy 권한 정책을 선택하고, 적당한 역할 이름을 입력해서 역할을 생성한다.</p>
<p><img alt="./cloudwatch3.png" src="https://greeng00se.github.io/assets/images/cloudwatch3-da10422b87e1901286b6d3e85e2c01cc.png" width="2650" height="1616"></p>
<p>EC2 인스턴스 목록으로 들어가서, CloudWatch Agent를 설치할 EC2 인스턴스를 클릭한다.<br>
<!-- -->작업 → 보안 → IAM 역할 수정에서 이전에 생성한 역할을 지정한다.</p>
<p><img alt="./cloudwatch4.png" src="https://greeng00se.github.io/assets/images/cloudwatch4-1e7eddc7e8dd890ac18352e900df8e07.png" width="1764" height="800"></p>
<h3 id="설치">설치</h3>
<p>환경은 다음과 같다.</p>
<p>OS: ubuntu 22.04<br>
<!-- -->인스턴스 유형: t4g.small (ARM64)</p>
<p>아래 명령어를 입력하여 설치한다.</p>
<pre><code class="language-bash">wget https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/arm64/latest/amazon-cloudwatch-agent.deb
sudo dpkg -i -E ./amazon-cloudwatch-agent.deb
</code></pre>
<p><a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudWatch/latest/monitoring/install-CloudWatch-Agent-commandline-fleet.html">사용 설명서</a>에 각 인스턴스 유형마다 다운로드 링크가 자세하게 안내되어 있다.</p>
<h3 id="wizard">Wizard</h3>
<p>CloudWatch Wizard를 사용하면 간단하게 설정 파일 생성할 수 있다.<br>
<!-- -->로그를 수집하도록 설정하는 경우 Wizard 실행 명령어 입력 전 log 파일의 절대 경로를 복사해두는 것이 좋다.<br>
<!-- -->아래의 명령어를 입력하여 Wizard를 실행할 수 있다.</p>
<pre><code class="language-bash">sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-config-wizard
</code></pre>
<p>설정을 진행하다 보면 설정 파일이 어떻게 구성될지 확인할 수 있다.<br>
<!-- -->로그를 추가할 것이냐고 물어보는 입력창이 나오면 준비해뒀던 로그 파일의 절대 경로를 입력한다.</p>
<p><img alt="./cloudwatch5.png" src="https://greeng00se.github.io/assets/images/cloudwatch5-67d1bd59d4552f4fe481452eddc78a5e.png" width="2320" height="1328"></p>
<p>중간에 SSM parameter store에 설정 파일을 저장할 것이냐고 물어보는 창이 나온다.</p>
<pre><code class="language-bash">Do you want to store the config in the SSM parameter store?
1. yes
2. no
</code></pre>
<p>추가적으로 설정하지 않는 경우 2번을 선택한다.<br>
<!-- -->Parameter Store 관리에 대한 내용은 다음의 <a href="https://dev.classmethod.jp/articles/manage-the-cloudwatch-agent-from-the-parameter-store/">문서</a>를 참고하면 좋을 거 같다.<br>
<!-- -->설정이 완료되면 <code>/opt/aws/amazon-cloudwatch-agent/bin/config.json</code> 에 설정에 대한 내용이 저장된다.</p>
<h3 id="설정-파일-적용">설정 파일 적용</h3>
<p>아래의 명령어를 입력하여 설정파일을 적용할 수 있다.<br>
<!-- -->file 뒤에는 설정 파일에 대한 절대경로(아래 명령어 기준 기본 생성 위치)를 입력하면 된다.</p>
<pre><code class="language-bash">sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -s -c file:/opt/aws/amazon-cloudwatch-agent/bin/config.json
</code></pre>
<h3 id="typesdb-no-such-file-or-directory-에러">types.db: no such file or directory 에러</h3>
<p>다음과 같은 에러가 발생한다면 types.db 파일을 생성해서 문제를 해결할 수 있다.</p>
<pre><code class="language-bash">Error running agent: Error loading config file /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.toml: error parsing socket_listener, open /usr/share/collectd/types.db: no such file or directory
</code></pre>
<p>types.db 파일 생성</p>
<pre><code class="language-bash">sudo mkdir /usr/share/collectd
sudo touch /usr/share/collectd/types.db
</code></pre>
<h3 id="지표-확인">지표 확인</h3>
<p>CloudWatch Metrics에 가보면 CWAgent라는 네임스페이스가 추가된 것을 볼 수 있다.</p>
<p><img alt="./cloudwatch6.png" src="https://greeng00se.github.io/assets/images/cloudwatch6-06ead809f7510938baee41505bc72b97.png" width="2638" height="708"></p>
<p>다음과 같이 설정 파일에 네임스페이스를 추가하여 지표에 대한 네임스페이스를 변경할 수 있다.</p>
<pre><code class="language-json">{
  "metrics": {
    "namespace": "2023-hello-world",
    ......
   },
} 
</code></pre>
<h3 id="로그">로그</h3>
<p>CloudWatch → 로그 그룹으로 가면 Wizard로 추가한 로그를 확인할 수 있다.</p>
<p><img alt="./cloudwatch7.png" src="https://greeng00se.github.io/assets/images/cloudwatch7-a86dfc0db307ddf7d1660d2b9e419c96.png" width="2792" height="1652"></p>
<h2 id="참고-자료">참고 자료</h2>
<p><a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">CloudWatch란 무엇입니까?</a><br>
<a href="https://aws.amazon.com/ko/cloudwatch/pricing/">Amazon CloudWatch 요금</a><br>
<a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">Linux 인스턴스 지표</a><br>
<a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudWatch/latest/monitoring/install-CloudWatch-Agent-commandline-fleet.html">서버에 CloudWatch 에이전트 설치 및 실행</a><br>
<a href="https://dev.classmethod.jp/articles/manage-the-cloudwatch-agent-from-the-parameter-store/">CloudWatch Agent를 Parameter Store에서 관리해 보기</a><br>
<a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudWatch/latest/monitoring/CloudWatch-Agent-Configuration-File-Details.html">CloudWatch에이전트 구성 파일</a></p>]]></content>
        <category label="cloudwatch" term="cloudwatch"/>
        <category label="log" term="log"/>
        <category label="monitoring" term="monitoring"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[경로 이미지 생성하기 - 비동기 처리]]></title>
        <id>https://greeng00se.github.io/route-image-async-with-event</id>
        <link href="https://greeng00se.github.io/route-image-async-with-event"/>
        <updated>2023-08-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[이전 글]]></summary>
        <content type="html"><![CDATA[<h2 id="이전-글">이전 글</h2>
<p><a href="https://greeng00se.github.io/route-image-intro">경로 이미지 생성하기 - 기술 선택</a><br>
<a href="https://greeng00se.github.io/route-image-implementation">경로 이미지 생성하기 - 구현</a></p>
<h2 id="개요">개요</h2>
<p>현재 여행을 마치는 경우, 감상을 생성하는 경우 이미지 생성 요청이 이루어진다.<br>
<!-- -->경로 이미지 생성의 경우 위치 정보의 개수에 정비례하여 생성 시간이 증가한다.<br>
<!-- -->따라서 비동기로 이미지 생성 요청을 처리하여 사용자의 경험을 개선시킬 수 있다고 생각했다.</p>
<h3 id="주기능의-응답속도-개선">주기능의 응답속도 개선</h3>
<p>여행 종료와 감상 생성이 주기능이고, 이미지 생성 기능은 부기능이다.<br>
<!-- -->하지만 현재 여행 종료와 감상 생성의 응답 속도가 경로 이미지 생성 시간에 영향을 받고 있다.<br>
<!-- -->경로 이미지 생성은 비동기 처리하여도 애플리케이션 사용에 문제가 되지 않는다.<br>
<!-- -->소요 시간이 1초 이상 걸리는 경우가 존재하기에 이미지 생성을 비동기 처리하고 여행 종료와 감상 생성 기능의 응답 시간을 개선하는 것이 더 중요하다.</p>
<h3 id="확장성-대비">확장성 대비</h3>
<p>현재 10분 간격으로 위치 정보를 서버에 저장하고 있다.<br>
<!-- -->조금 더 짧은 간격으로 위치 정보를 그리는 경우 하나의 여행에 많은 위치 정보가 저장될 수밖에 없고 따라서 경로 이미지 생성에 걸리는 시간이 더 길어질 수 있다.<br>
<!-- -->따라서 추후에 더 짧은 간격으로 위치 정보를 저장하는 경우를 대비하여 이미지 생성은 비동기로 처리하는 것이 합당하다.</p>
<h2 id="비동기-처리">비동기 처리</h2>
<p>@Async를 사용하면 간단하게 메서드를 비동기로 동작하도록 만들 수 있다.</p>
<h3 id="비동기-설정">비동기 설정</h3>
<p>사용하기 전에 설정 파일을 하나 만들어서 EnableAsync 설정을 해야한다.<br>
<!-- -->해당 설정을 적용하면 비동기적으로 실행하려는 메서드에 @Async 애너테이션을 붙여주기만 하면 비동기로 동작한다.</p>
<pre><code class="language-java" metastring="title=&quot;AsyncConfig&quot;">@EnableAsync
@Configuration
public class AsyncConfig {
}
</code></pre>
<p>스프링 부트를 사용하지 않는 경우 기본적으로 비동기 처리를 할 때 매번 새로운 스레드를 생성하기 때문에 스레드 풀 설정을 따로 해줘야 한다.  하지만 스프링 부트를 사용하는 경우 ThreadPoolTaskExecutor를 따로 설정하지 않아도 기본적으로 스프링 부트가 생성을 도와준다.</p>
<blockquote>
<p>In the absence of an Executor bean in the context, Spring Boot auto-configures a ThreadPoolTaskExecutor with sensible defaults that can be automatically associated to asynchronous task execution (@EnableAsync) and Spring MVC asynchronous request processing.
7.7. Task Execution and Scheduling, Spring Boot Docs</p>
</blockquote>
<h3 id="async-적용">@Async 적용</h3>
<p>이미지 생성기에 Async 애너테이션을 붙여 비동기로 동작하도록 한다.</p>
<pre><code class="language-java" metastring="title=&quot;RouteImageGenerator&quot;">@Async
public void generate(
        List&lt;Double&gt; latitudes,
        List&lt;Double&gt; longitudes,
        List&lt;Double&gt; pointedLatitudes,
        List&lt;Double&gt; pointedLongitudes,
        Long tripId
) {
    // 이미지 생성
    RouteImageDrawer routeImageDrawer = RouteImageDrawer.from(IMAGE_SIZE);
    Coordinates coordinates = Coordinates.of(latitudes, longitudes);
    Coordinates pointedCoordinates = Coordinates.of(pointedLatitudes, pointedLongitudes);
    drawImage(coordinates, routeImageDrawer, pointedCoordinates);

    // 이미지 저장
    String imageName = routeImageUploader.upload(routeImageDrawer.bufferedImage());

    // 자원 할당 해제
    routeImageDrawer.dispose();

    // 데이터베이스 값 변경
    Trip trip = tripRepository.findById(tripId)
        .orElseThrow();
    trip.changeRouteImageUrl(imageUrl);
    tripRepository.save(trip);
}
</code></pre>
<h3 id="비동기-처리시-문제점">비동기 처리시 문제점</h3>
<p>현재 이미지 생성을 하고 저장 후, 저장 경로를 DB에 반영해야 한다.<br>
<!-- -->따라서 패키지 간 순환 참조 형태가 되며 의존성 방향이 문제가 생긴다.</p>
<mermaid value="graph LR
    trip[trip: 여행 관련 패키지] --> draw[draw: 이미지 생성 기능을 포함하고 있는 패키지]
    draw --> trip"></mermaid>
<p>이를 해결하기 위해서는 인터페이스를 사용하는 방법과 이벤트를 사용하는 방법이 있다.<br>
<!-- -->인터페이스를 사용한다면 다음과 같은 구조가 된다.</p>
<mermaid value="graph LR
	subgraph draw
		direction LR
		RG[RouteImageGenerator] -- DB 반영 요청 --> ILR[ImageLinkTripRepository]
	end
  subgraph trip
		direction LR
		TS[TripService] -- 이미지 생성 --> RG
		ILRI[ImageLinkTripRepositoryImpl] -- 구현 --> ILR
	end

	trip --> draw"></mermaid>
<p>패키지 간 의존성은 해결되었지만, 이미지 경로 저장을 위해 tripId를 받아야하는 등의 논리적인 의존성은 아직 해결되지 않았다.<br>
<!-- -->따라서 이벤트를 사용하기로 했다.</p>
<h2 id="이벤트-사용">이벤트 사용</h2>
<p>스프링의 애플리케이션 이벤트를 사용하면 비즈니스 로직의 비관심사(ex. 경로 이미지 생성)을 효율적인 방법으로 처리할 수 있다.</p>
<h3 id="이벤트-발행">이벤트 발행</h3>
<p>이벤트를 사용하려면 먼저 이벤트를 발행해야 한다.<br>
<!-- -->스프링에서는 ApplicationEventPublisher 인터페이스를 사용하여 이벤트를 발행할 수 있다.<br>
<!-- -->해당 인터페이스는 내부적으로 ApplicationContext가 구현하여 이벤트를 발행한다.</p>
<pre><code class="language-java" metastring="title=&quot;TripService &amp; TripUpdateEvent&quot;">public void updateTripById(LoginUser loginUser, Long tripId, TripUpdateRequest tripUpdateRequest) {
    ...

    // 이벤트 발행
    applicationEventPublisher.publishEvent(new TripUpdateEvent(trip.id()));
}

public record TripUpdateEvent(Long tripId) {
}
</code></pre>
<p>이벤트를 발행할 때 발행하는 이벤트명이 중요하다.<br>
<!-- -->이벤트를 구독하는 도메인의 행위를 담고 있는 이벤트를 발행(ex. RouteImageGenerateEvent)한다면 논리적인 의존 관계가 남아있기에 이벤트를 적절히 사용했다고 보기 어렵다.<br>
<!-- -->발행하는 이벤트명은 주기능이 어떤 행위(ex. TripUpdateEvent)를 했는지에 대한 정보가 담겨있는 이벤트명으로 발행하는 것이 중요하다.</p>
<h3 id="이벤트-구독">이벤트 구독</h3>
<p>이벤트를 구독하여 실행하는 메서드는 비동기로 처리하기 위하여 <code>@Async</code> 애너테이션을 적용했다.<br>
<!-- -->이벤트의 구독은 여행이 정상적으로 종료될 때 여행에 대한 정보를 가지고 경로 이미지를 생성하기 위해 <code>@TransactionalEventListener</code>를 사용했다.</p>
<admonition title="TransactionPhase 설정" type="note"><p>TransactionPhase을 사용하여 트랜잭션 이벤트를 어떤 단계에서 수신하고 처리할지를 지정할 수 있다.</p><p>AFTER_COMMIT(기본값): 트랜잭션이 정상적으로 커밋 되는 경우 이벤트 실행<br>
<!-- -->AFTER_ROLLBACK: 트랜잭션이 롤백되는 경우 이벤트 실행<br>
<!-- -->AFTER_COMPLETION: 트랜잭션이 커밋 또는 롤백 되었을 경우 이벤트 실행<br>
<!-- -->BEFORE_COMMIT: 트랜잭션이 커밋 되기 전 이벤트 실행</p></admonition>
<p>이미지 생성의 경우 트랜잭션에서 제외하기 위해 @Transactional 애너테이션을 사용하지 않았다.</p>
<pre><code class="language-java" metastring="title=&quot;TripUpdateEventHandler&quot;">@Component
public class TripUpdateEventHandler {

    private final RouteImageGenerator routeImageGenerator;
    private final TripRepository tripRepository;

    public TripUpdateEventHandler(RouteImageGenerator routeImageGenerator, TripRepository tripRepository) {
        this.routeImageGenerator = routeImageGenerator;
        this.tripRepository = tripRepository;
    }

    @Async
    @TransactionalEventListener(phase = AFTER_COMMIT)
    public void handle(TripUpdateEvent tripUpdateEvent) {
        Trip trip = tripRepository.getTripWithPoints(tripUpdateEvent.tripId());

        String imageUrl = routeImageGenerator.generate(
                trip.getLatitudes(),
                trip.getLongitudes(),
                trip.getPointedLatitudes(),
                trip.getPointedLongitudes()
        );

        trip.changeRouteImageUrl(imageUrl);
        tripRepository.save(trip);
    }
}
</code></pre>
<p>이벤트를 사용함으로써 패키지 간 순환 참조 문제가 다음과 같이 해결되었다.<br>
<!-- -->또한 주기능과 부기능을 분리함으로써 경로 이미지 생성 기능에 대한 전체적인 결합도를 낮추었다.</p>
<mermaid value="graph LR
    subgraph trip
        TripServcie -- 발행 --> TripUpdateEvent
        TripRepository
    end

    subgraph draw
        TripUpdateEventHandler -- 구독 후 이미지 생성 --> TripUpdateEvent
        TripUpdateEventHandler -- 생성된 이미지 경로 저장 --> TripRepository
    end"></mermaid>
<h3 id="테스트">테스트</h3>
<p>비동기로 동작하는 메서드를 테스트하기 위해서는 아래와 같은 방법이 있다.</p>
<!-- -->
<!-- -->
<div class="tabs-container tabList__CuJ"><ul role="tablist" aria-orientation="horizontal" class="tabs"><li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_LNqP">비동기 메서드가 종료될 때까지 대기 후 검증</li><li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_LNqP tabs__item--active">테스트 할 때만 비동기를 동기로 변경하여 검증</li></ul><div class="margin-top--md"><div role="tabpanel" class="tabItem_Ymn6" hidden=""><pre><code class="language-java">@SpringBootTest
public class TripUpdateEventHandlerIntegrationTest {

    ...

    @Test
    void 여행수정_이벤트를_발생시키면_이미지를_생성_요청을_한다() {
        // given
        TripUpdateEvent tripUpdateEvent = new TripUpdateEvent(1L);
        given(tripRepository.getTripWithPoints(tripUpdateEvent.tripId()))
                .willReturn(여행());

        // when
        transactionTemplate.executeWithoutResult(action -&gt; applicationEventPublisher.publishEvent(tripUpdateEvent));

        // then
        then(routeImageGenerator)
                .should(Mockito.timeout(5000).times(1))
                .generate(any(), any(), any(), any());
    }
}
</code></pre></div><div role="tabpanel" class="tabItem_Ymn6"><pre><code class="language-java">@ContextConfiguration(classes = TestSyncConfig.class)
@SpringBootTest
public class TripUpdateEventHandlerIntegrationTest {

    ...

    @Test
    void 여행수정_이벤트를_발생시키면_이미지를_생성_요청을_한다() {
        // given
        TripUpdateEvent tripUpdateEvent = new TripUpdateEvent(1L);
        given(tripRepository.getTripWithPoints(tripUpdateEvent.tripId()))
                .willReturn(여행());

        // when
        transactionTemplate.executeWithoutResult(action -&gt; applicationEventPublisher.publishEvent(tripUpdateEvent));

        // then
        then(routeImageGenerator)
                .should(times(1))
                .generate(any(), any(), any(), any());
    }
}
</code></pre></div></div></div>
<p>처음에는 테스트에서만 동기로 설정 후 검증하려고 했다.<br>
<!-- -->통합 테스트에선 <code>트랜잭션이 정상 종료되었을 때 비동기로 이벤트를 구독하여 이미지 생성 메서드를 호출하는지</code> 검증이 필요했기 때문에 최종적으로  <code>Mockito.timeout</code> 메서드를 사용하여 비동기 메서드가 통과될 때까지 대기하는 방향으로 변경했다.</p>
<h2 id="결과">결과</h2>
<p><img alt="./time.png" src="https://greeng00se.github.io/assets/images/time-8bef9a6cf2dcace85f12ae5624da94f5.png" width="1682" height="678"></p>
<p>위 응답 시간은 위치 정보 1000개를 기준으로 테스트한 값이다.<br>
<!-- -->응답 시간에 이미지 생성 시간이 포함되지 않아서 성능이 개선된 것을 볼 수 있다.</p>
<h2 id="참고-자료">참고 자료</h2>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.task-execution-and-scheduling">7.7. Task Execution and Scheduling, Spring Boot Docs</a><br>
<a href="https://www.baeldung.com/spring-events">Spring Events, Baeldung</a><br>
<a href="https://techblog.woowahan.com/7835/">회원시스템 이벤트기반 아키텍처 구축하기</a></p>]]></content>
        <category label="async" term="async"/>
        <category label="event" term="event"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[경로 이미지 생성하기 - 구현]]></title>
        <id>https://greeng00se.github.io/route-image-implementation</id>
        <link href="https://greeng00se.github.io/route-image-implementation"/>
        <updated>2023-08-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[개요]]></summary>
        <content type="html"><![CDATA[<h2 id="개요">개요</h2>
<p>여행에 대한 경로를 보여주기 위해 경로 이미지를 생성하는 기능을 추가했다.<br>
<!-- -->경로 이미지에 대한 요구사항 및 기술 선택에 대한 내용은 <a href="https://greeng00se.github.io/route-image-intro">링크</a>에 있다.</p>
<h3 id="구현-결과">구현 결과</h3>
<p><img alt="./result.png" src="https://greeng00se.github.io/assets/images/result-c2887223d62510a96c9c8f733bf5edf6.png" width="1840" height="714"></p>
<p>예시 데이터는 다음과 같다.<br>
<strong>서울역(점)</strong> → 신사역 → 노량진역 → 홍대입구역 → 종로3가역 → 옥수역 → <strong>구로역(점)</strong> → 신림역 → 발산역</p>
<pre><code class="language-java" metastring="title=&quot;예시 데이터&quot;">List&lt;Double&gt; x = List.of(
        126.97094933811682, 127.02154822802501, 126.94218991864345, 126.92402556641424,
        126.99265358592287, 127.01779856076462, 126.88474839801178, 126.92900751277035, 126.83930056313639
);
List&lt;Double&gt; y = List.of(
        37.55302829553499, 37.51619698970427, 37.51294119442773, 37.5565933969331,
        37.57034879708931, 37.54027238225762, 37.50129417536773, 37.48258811529137, 37.557607696911184
);
List&lt;Double&gt; xPoints = List.of(126.97094933811682, 126.88474839801178);
List&lt;Double&gt; yPoints = List.of(37.55302829553499, 37.50129417536773);
</code></pre>
<h3 id="image_size--route_size">IMAGE_SIZE &amp; ROUTE_SIZE</h3>
<pre><code class="language-java" metastring="title=&quot;RouteImageGenerator.java&quot;">private static final int IMAGE_SIZE = 800;
private static final int ROUTE_SIZE = 600;
</code></pre>
<p>코드를 보면 IMAGE_SIZE와 ROUTE_SIZE가 있다.<br>
<!-- -->IMAGE_SIZE는 말 그대로 이미지의 width와 height를 의미한다.<br>
<!-- -->ROUTE_SIZE의 경우 상하좌우 100px 만큼의 간격을 위해 존재한다.<br>
<!-- -->따라서 실제 경로 이미지의 크기는 600 * 600 사이즈로 생성된다.</p>
<p><img alt="./600.png" src="https://greeng00se.github.io/assets/images/600-50ee65176288cb73d2c777d255460f4f.png" width="976" height="970"></p>
<p><strong>사이즈 변경의 이유</strong></p>
<p>255 * 255 정도의 작은 사이즈로 이미지를 생성해보려고 했는데, 이미지의 선명도가 좋지 않아 800 * 800 사이즈로 변경했다.</p>
<h2 id="주요-클래스">주요 클래스</h2>
<h3 id="요약">요약</h3>
<table><thead><tr><th>클래스명</th><th>설명</th><th>특이사항</th></tr></thead><tbody><tr><td>Coordinate</td><td>위도, 경도로 이루어진 위치 값</td><td>좌표를 뜻하지만 여행 도메인에 포함된 Point 클래스와 구분하기 위해 longitude, latitude를 사용하지 않고 x, y 사용</td></tr><tr><td>Coordinates</td><td>Coordinate의 일급 컬렉션</td><td>-</td></tr><tr><td>Position</td><td>실제 이미지 생성에 사용할 위치 값</td><td>Integer 타입의 x, y 사용</td></tr><tr><td>Positions</td><td>Positions의 일급 컬렉션</td><td>-</td></tr><tr><td>RouteImageDrawer</td><td>실제 이미지에 경로를 그려주는 클래스 BufferedImage, Graphics2D를 가지고 있음</td><td>이미지 생성에 필요한 상수가 정의되어 있음</td></tr><tr><td>RouteImageUploader</td><td>BufferedImage를 받아 서버에 업로드 하는 클래스</td><td>현재 업로드 위치가 정해지지 않아 일단 기본(프로젝트 루트) 위치에 생성</td></tr><tr><td>RouteImageGenerator</td><td>이미지를 생성하고 업로드하는 서비스</td><td>여행 종료, 감상 저장시 해당 클래스를 통해 이미지 생성 요청</td></tr><tr><td>BufferedImage(AWT)</td><td>이미지 데이터를 처리하고 조작하는 데 사용</td><td>왼쪽 상단의 좌표가 (0, 0)</td></tr><tr><td>Graphics2D(AWT)</td><td>선 그리기, 색상 관리 등을 지원하는 클래스 실제 해당 클래스의 draw 메서드를 경로를 그림</td><td>JDK 1.2 이후에 추가됨, 2D(평면) 그래픽 환경을 지원, bufferedImage.createGraphics 메서드를 통해 생성</td></tr></tbody></table>
<h3 id="의존관계">의존관계</h3>
<mermaid value="graph TD
  C1[Coordinates] --> C[Coordinate]
  P1[Positions] --> P[Position]

	RID[RouteImageDrawer] -- &quot;중앙 정렬된 Positions를 받아 이미지 생성&quot; --> P1
	RID --> B[BufferedImage]
	RID --> G[Graphics2D]

	C1 -- &quot;calculatePositions 실제 이미지에 생성에 필요한 위치 계산&quot; --> P1

	RIU[RouteImageUploader] --> B
	RIG[RouteImageGenerator] --> RID
	RIG --> RIU
	RIG --> C1
	RIG --> P1"></mermaid>
<h3 id="coordinates위도-경도의-일급-컬렉션">Coordinates(위도, 경도의 일급 컬렉션)</h3>
<p><code>List&lt;Double&gt;</code> 2개(위도, 경도)인 형태로 관리하는 방법이 있었지만, 위치 점을 여러개 찍는 부분에서 로직이 복잡해 질 것 같아서 Coordinate(x, y)와 일급 컬렉션인 Coordinates로 관리하기로 했다.<br>
<!-- -->Coordinates 클래스에는 다음 두 개의 인터페이스가 존재한다.</p>
<ul>
<li>calculatePositions: 경로 이미지의 크기를 받아 실제 이미지 생성시 사용될 Positions를 반환</li>
<li>indexOf: 다른 Coordinates를 받아 동일한 위치점에 해당하는 인덱스를 반환하는</li>
</ul>
<p>Positions 계산 로직은 다음과 같다.<br>
<!-- -->위도, 경도 각각에 대한 부분을 이미지 생성시 필요한 값으로 변환한다.</p>
<pre><code class="language-java" metastring="title=&quot;Coordinates.java&quot;">// 호출
// List&lt;Integer&gt; xPositions = toPositions(xValues, maxDifference, routeImageSize);
// List&lt;Integer&gt; yPositions = toPositions(yValues, maxDifference, routeImageSize);

private List&lt;Integer&gt; toPositions(List&lt;Double&gt; values, Double maxDifference, Integer routeImageSize) {
    Double minValue = Collections.min(values);
    return values.stream()
            .map(value -&gt; normalizeCoordinate(value, maxDifference, minValue))
            .map(value -&gt; mapToPosition(value, routeImageSize))
            .toList();
}

private double normalizeCoordinate(Double coordinate, Double maxDifference, Double minValue) {
    return (coordinate - minValue) / maxDifference;
}

private int mapToPosition(Double coordinate, Integer routeImageSize) {
    return (int) (coordinate * routeImageSize);
}
</code></pre>
<p>위도로 예시든 내용이다.</p>
<ol>
<li>Collections.min(values) → 위도 리스트의 최소값을 구한다.</li>
<li>normalizeCoordinate → 각각의 위도 값에서 최소값을 빼고 0 ~ 1 사이 값으로 변환 후 <strong>위경도의 최대 차이</strong>로 나눈다.</li>
<li>mapToPosition → 그래프 크기를 받아 0 ~ 1 사이 값을 실제 이미지를 위한 위치값으로 변환한다.</li>
</ol>
<h3 id="positions실제-이미지-생성에-사용할-위치">Positions(실제 이미지 생성에 사용할 위치)</h3>
<p>Positions 클래스에는 다음 다섯 개의 인터페이스가 존재한다.</p>
<ul>
<li>align: 이미지 사이즈와 경로 이미지 사이즈를 받아 Position 값들을 중앙 정렬한다.</li>
<li>getPositionsByIndexes: 인덱스 리스트를 받아 입력받은 인덱스에 해당하는 값들을 반환한다.</li>
<li>size: 크기를 반환한다.</li>
<li>xPositions: x 값들을 반환한다.</li>
<li>yPositions: y 값들을 반환한다.</li>
</ul>
<p>중앙 정렬 로직은 다음과 같다.</p>
<pre><code class="language-java" metastring="title=&quot;Positions.java&quot;">public Positions align(int imageSize, int routeSize) {
    int xOffset = calculateOffset(Position::x, imageSize);
    int yOffset = calculateOffset(Position::y, imageSize);

    return items.stream()
            .map(item -&gt; new Position(item.x() + xOffset, imageSize - (item.y() + yOffset)))
            .collect(collectingAndThen(toList(), Positions::new));
}

private int calculateOffset(ToIntFunction&lt;Position&gt; positionToInteger, int imageSize) {
    List&lt;Integer&gt; positions = items.stream()
            .mapToInt(positionToInteger)
            .boxed()
            .toList();

    int midValue = (Collections.min(positions) + Collections.max(positions)) / 2;
    return imageSize / 2 - midValue;
}
</code></pre>
<p>상하좌우 여백을 동일하게 주기 위해서 offset 값을 구해서 x, y 값에 각각 더하는 형태로 중앙 정렬을 수행했다.<br>
<!-- -->BufferedImage를 사용할 때 왼쪽 상단의 좌표 (0, 0) 기준으로 아래로 내려갈수록 y 값이 커지고, 오른쪽으로 갈 수록 x 값이 커진다.</p>
<p><img alt="./800.png" src="https://greeng00se.github.io/assets/images/800-88542ba3914ad40b45b999e95df96cdf.png" width="968" height="978"></p>
<p>따라서 최종적으로 이미지를 생성하기 위한 값을 다음과 같이 구했다.</p>
<p>x 값 → 계산한 offset 그대로 더한다.<br>
<!-- -->y 값 → imageSize(800)에서 y + offset 값을 뺀다.</p>
<h3 id="routeimagedrawer실제-이미지에-경로를-그려주는-클래스">RouteImageDrawer(실제 이미지에 경로를 그려주는 클래스)</h3>
<p>BufferedImage, Graphics2D를 필드로 가지고 있는 클래스다.<br>
<!-- -->그림을 그리기 위해 설정한 상수들이 존재한다.</p>
<pre><code class="language-java" metastring="title=&quot;RouteImageDrawer.java&quot;">// RGB에 각각 8비트씩 할당한 값을 24비트 트루컬러라 부른다.
// 해당 설정은 24비트 + 8비트(alpha, 투명도)를 추가한 32비트 이미지 타입이다.
// 이를 RGBA라고 부른다.
private static final int IMAGE_TYPE = BufferedImage.TYPE_INT_ARGB;
// 배경 투명색
private static final Color TRANSPARENT = new Color(0, 0, 0, 0);
// 경로를 위한 STROKE
private static final int LINE_STROKE_WIDTH = 7;
private static final Stroke LINE_STROKE = new BasicStroke(LINE_STROKE_WIDTH, CAP_ROUND, JOIN_ROUND);
// 위치 점을 위한 STROKE
private static final int POINT_STROKE_WIDTH = 20;
private static final Stroke POINT_STROKE = new BasicStroke(POINT_STROKE_WIDTH, CAP_ROUND, JOIN_ROUND);
// 안티앨리어싱 등 화질 개선을 위한 설정
private static final Map&lt;Object, Object&gt; renderingHints = Map.of(
        RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON,
        RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY,
        RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC
);
</code></pre>
<p>RouteImageDrawer 클래스에는 다음 세 개의 인터페이스가 존재한다.</p>
<ul>
<li>drawLine: 선을 그린다.</li>
<li>drawPoint: 점을 찍는다.</li>
<li>dispose: 자원 할당을 해제한다.</li>
</ul>
<p>dispose의 경우 내부에서 생성된 graphics2D에 대한 자원 할당을 해제하는 메서드인 graphics2D.dispose를 호출한다.</p>
<h2 id="이미지-생성-flow">이미지 생성 Flow</h2>
<h3 id="1-이미지-생성-준비">1. 이미지 생성 준비</h3>
<mermaid value="sequenceDiagram
    외부 클래스 ->> RouteImageGenerator: 이미지 생성 요청(위경도, 위치 점을 찍을 값 전달)
    RouteImageGenerator->>RouteImageDrawer: ImageSize를 전달하여 객체 생성, 내부에서 BufferedImage, Graphincs2D 생성
    RouteImageGenerator->>Coordinates1(위경도): 위경도 이용하여 Coordinates1 생성
    RouteImageGenerator->>Coordinates2(위치점): 위치점 이용하여 Coordinates2 생성
"></mermaid>
<h3 id="2-선-그리기-요청">2. 선 그리기 요청</h3>
<mermaid value="sequenceDiagram
    RouteImageGenerator->>Coordinates1(위경도): 정렬된 Positions를 생성 요청
    Coordinates1(위경도)->>RouteImageGenerator: 정렬된 Positions 반환
    RouteImageGenerator->>RouteImageDrawer: 정렬된 Positions를 경로 그리기 요청"></mermaid>
<h3 id="3-위치-점-그리기-요청">3. 위치 점 그리기 요청</h3>
<mermaid value="sequenceDiagram
    RouteImageGenerator->>Coordinates1(위경도): Coordinate2(위치점)를 전달하고 해당 위치점과 일치하는 Coordinate의 인덱스 생성 요청
    Coordinates1(위경도)->>RouteImageGenerator: 위치점에 해당하는 인덱스(List<Integer>) 반환
    RouteImageGenerator->>정렬된 Positions: 인덱스(List<Integer>)를 전달하여 인덱스에 해당하는 Positions 생성 요청
    정렬된 Positions->>RouteImageGenerator: 위치점에 해당하는 Positions 반환(pointPositions)

    RouteImageGenerator->>RouteImageDrawer: pointPositions를 전달하여 위치 점 그리기 요청"></mermaid>
<h3 id="4-업로드-요청">4. 업로드 요청</h3>
<mermaid value="sequenceDiagram
  	RouteImageGenerator->>RouteImageUploader: bufferedImage(RouteImageDrawer에서 getter 사용)를 전달하여 이미지 저장 요청
  	RouteImageUploader->>RouteImageGenerator: 저장 후 저장된 이미지명(또는 url) 반환
  	RouteImageGenerator->>외부 클래스: 저장된 이미지명(또는 url) 반환"></mermaid>
<h3 id="전체-flow">전체 Flow</h3>
<mermaid value="sequenceDiagram
    외부 클래스 ->> RouteImageGenerator: 이미지 생성 요청(위경도, 위치 점을 찍을 값 전달)
    RouteImageGenerator->>RouteImageDrawer: ImageSize를 전달하여 객체 생성, 내부에서 BufferedImage, Graphincs2D 생성
    RouteImageGenerator->>Coordinates1(위경도): 위경도 이용하여 Coordinates1 생성
    RouteImageGenerator->>Coordinates2(위치점): 위치점 이용하여 Coordinates2 생성
    RouteImageGenerator->>Coordinates1(위경도): 정렬된 Positions를 생성 요청
    Coordinates1(위경도)->>RouteImageGenerator: 정렬된 Positions 반환
    RouteImageGenerator->>RouteImageDrawer: 정렬된 Positions를 경로 그리기 요청
    RouteImageGenerator->>Coordinates1(위경도): Coordinate2(위치점)를 전달하고 해당 위치점과 일치하는 Coordinate의 인덱스 생성 요청
    Coordinates1(위경도)->>RouteImageGenerator: 위치점에 해당하는 인덱스(List<Integer>) 반환
    RouteImageGenerator->>정렬된 Positions: 인덱스(List<Integer>)를 전달하여 인덱스에 해당하는 Positions 생성 요청
    정렬된 Positions->>RouteImageGenerator: 위치점에 해당하는 Positions 반환(pointPositions)

    RouteImageGenerator->>RouteImageDrawer: pointPositions를 전달하여 위치 점 그리기 요청
    RouteImageGenerator->>RouteImageUploader: bufferedImage(RouteImageDrawer에서 getter 사용)를 전달하여 이미지 저장 요청
    RouteImageUploader->>RouteImageGenerator: 저장 후 저장된 이미지명(또는 url) 반환
    RouteImageGenerator->>외부 클래스: 저장된 이미지명(또는 url) 반환
	"></mermaid>]]></content>
        <category label="image" term="image"/>
        <category label="awt" term="awt"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[경로 이미지 생성하기 - 파이썬]]></title>
        <id>https://greeng00se.github.io/route-image-python</id>
        <link href="https://greeng00se.github.io/route-image-python"/>
        <updated>2023-07-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[개요]]></summary>
        <content type="html"><![CDATA[<h3 id="개요">개요</h3>
<p>이전에 기술 구현 가능 여부를 조사하면서 파이썬을 사용한 내용을 정리한 내용이다.</p>
<h3 id="사용-기술">사용 기술</h3>
<p>언어: Python 3.10<br>
<!-- -->이미지 생성: matplotlib<br>
<!-- -->서비스: AWS Lambda, AWS API Gateway<br>
<!-- -->이미지 저장 및 URL: AWS S3, AWS CloudFront</p>
<p>플로우는 다음과 같다.</p>
<mermaid value="graph LR
  Server -- 생성 요청 --> AG[API Gateway] --> Lambda --> S3
  Client --> CloudFront --> S3"></mermaid>
<h3 id="요구사항">요구사항</h3>
<p><img alt="./route.png" src="https://greeng00se.github.io/assets/images/route-89cacb9b7815a3191ab1f9d9e23c43a1.png" width="1014" height="902"></p>
<p>우측 상단의 경로 이미지를 생성하려고 한다.<br>
<!-- -->경로 이미지 생성에 대한 요구사항은 다음과 같다.</p>
<ul>
<li>위도, 경도로 이루어진 배열을 입력받는다.</li>
<li>이미지 생성</li>
<li>선과 점 표현</li>
<li>투명한 배경색</li>
<li>위경도 차이가 크든 작든 제공하는 이미지 내에 경로가 다 포함되어 있어야 한다.</li>
</ul>
<h3 id="이미지-출력-방식">이미지 출력 방식</h3>
<ol>
<li>위경도를 처리한 값으로 직접 경로를 그린 다음 이미지 형태로 저장</li>
<li>플롯을 그려주는 라이브러리 사용하여 이미지 형태로 저장</li>
</ol>
<p>이미지 출력 방식의 경우 1번과 2번을 고민했었다.<br>
<!-- -->파이썬으로는 플롯을 그려주는 라이브러리인 matplotlib을 사용했다.</p>
<h3 id="로컬에서-기능-구현">로컬에서 기능 구현</h3>
<pre><code class="language-python">import time

import matplotlib.pyplot as plt


def draw(point):
    start = time.time()
    x, y = zip(*point)
    pixel_x, pixel_y = convert_to_pixel_values(x, y)
    draw_lines(pixel_x, pixel_y)
    end = time.time()
    print(end - start)
    
def convert_to_pixel_values(x, y):
    max_diff = max(max(x) - min(x), max(y) - min(y))
    return scale_to_pixel_values(x, max_diff), scale_to_pixel_values(y, max_diff)


def scale_to_pixel_values(points, max_diff):
    min_value = min(points)
    scaled_coordinates = [(p - min_value) / max_diff for p in points]
    return scaled_coordinates


def draw_lines(x, y):
    figure = plt.gcf()
    figure.set_size_inches(5, 5)
    plt.plot(x, y, c = 'w',linewidth=5)
    plt.scatter(x[3],y[3], c = 'w', s = 125)
    plt.axis('off')
    plt.savefig('name.png', transparent=True, format='png')

point = [
    [126.96352960597338, 37.590841000217125],
    [126.96987292787792, 37.58435564234159],
    [126.98128481452298, 37.58594375113966],
    [126.99360339342958, 37.58248524741927],
    [126.99867565340067, 37.56778118088622],
    [127.001935378366117, 37.55985240444085],
    [126.9831048919687, 37.548030119488665],
    [126.97189273528845, 37.5119879225856],
    [127.02689859997221, 37.48488593333883]
]

draw(point)
</code></pre>
<p>생성 결과는 아래와 같다. (예시를 위해 검은색으로 출력)</p>
<p><img alt="./routeImage.png" src="https://greeng00se.github.io/assets/images/routeImage-0eac25ba9b356cd034ade6e062c1ce19.png" width="500" height="500"></p>
<h3 id="aws-lambda">AWS Lambda</h3>
<p>썸네일 생성 서버를 따로 두기는 기능 대비 비용이 너무 클 것이라고 생각했다.<br>
<!-- -->따라서 서버리스로 파일을 처리했다.<br>
<!-- -->추가로 s3 접근은 boto3를 사용했다.</p>
<h3 id="람다-s3-접근을-위한-iam-생성">람다 S3 접근을 위한 IAM 생성</h3>
<p>AmazonS3FullAccess, AmazonS3ObjectLambdaExecutionRolePolicy 두가지를 추가해서 Lambda 전용 역할을 만들어 사용했다.</p>
<h3 id="람다-배포용-코드">람다 배포용 코드</h3>
<p>기술 구현 가능 여부를 확인할 땐 위치 점을 찍는 기능을 람다에 배포하지 않았다.</p>
<pre><code class="language-python">
import io
import uuid

import boto3
import matplotlib.pyplot as plt

PIXEL = 255
BUCKET_NAME = 'image-plot'
S3 = 's3'

def lambda_handler(event, context):
    x = event['x']
    y = event['y']
    image_name = str(uuid.uuid4())

    img_data = draw(x, y)
    s3 = boto3.client(S3)
    s3.put_object(Body=img_data.getvalue(), ContentType='image/png', Bucket=BUCKET_NAME, Key=image_name)
    url = f'https://{BUCKET_NAME}.s3.ap-northeast-2.amazonaws.com/{image_name}'

    return {
        'statusCode': 200,
        'body': url
    }

def draw(x, y):
    pixel_x, pixel_y = convert_to_pixel_values(x, y)
    img_data = draw_lines(pixel_x, pixel_y)
    plt.close()
    return img_data

def convert_to_pixel_values(x, y):
    max_diff = max(max(x) - min(x), max(y) - min(y))
    return scale_to_pixel_values(x, max_diff), scale_to_pixel_values(y, max_diff)

def scale_to_pixel_values(points, max_diff):
    min_value = min(points)
    scaled_coordinates = [(p - min_value) / max_diff for p in points]
    pixel_values = [int(p * PIXEL) for p in scaled_coordinates]
    return pixel_values

def draw_lines(x, y):
    plt.plot(x, y, 'k-', linewidth=10)
    plt.axis('off')
    img_data = io.BytesIO()
    plt.savefig(img_data, transparent=True, format='png')
    img_data.seek(0)
    return img_data

</code></pre>
<h3 id="layer-추가를-위한-zip-파일-생성">Layer 추가를 위한 zip 파일 생성</h3>
<p>matplotlib의 경우 외부 라이브러리기 때문에 따로 Layer를 추가해야 한다.<br>
<!-- -->zip 파일을 만들어서 업로드해야한다.<br>
<!-- -->이때 python의 Lambda 런타임에 대한 계층 경로는 python이다.<br>
<!-- -->따라서 압축한 zip 파일은 다음과 같은 구조를 띄어야 한다.</p>
<pre><code>pillow.zip
│ python/PIL
└ python/Pillow-5.3.0.dist-info
</code></pre>
<p>Ubuntu 기준 다음 명령어를 입력하여 생성을 진행했다.</p>
<pre><code>sudo apt update
sudo apt install zip
sudo apt install python3-pip

mkdir python
pip3 install matplotlib -t python # pip3 install 설치할_패키지 -t 설치_경로
zip -r my_layer.zip python # zip -r 압축_파일명 압축_파일이_존재하는_경로
</code></pre>
<h3 id="no-module-named-numpycore_multiarray_umath-에러"><code>No module named 'numpy.core._multiarray_umath'</code> 에러</h3>
<p>Layer 추가 후 람다 실행 시 발생한 에러였다.<br>
<!-- -->처음에 mac에서 zip 파일을 생성해서 업로드했는데 해당 문제가 발생했다.<br>
<!-- -->이는 lambda가 돌아가는 동일한 환경에서 layer를 위한 zip 파일을 만들지 않아서 발생하는 문제다.<br>
<!-- -->간단하게 ec2 인스턴스를 하나 만들어서 따로 Layer를 생성하면 문제가 발생하지 않는다.</p>
<h3 id="적정기술에-대한-생각">적정기술에 대한 생각</h3>
<p>프로젝트에 Lambda와 Python을 사용하려고 했지만 아쉽게도 반려당했다.<br>
<!-- -->AWS Lambda를 사용하는 것은 인스턴스에 해당 코드를 배포하는 것보다 더 효율적인 방법일 수 있다.<br>
<!-- -->하지만 현재 프로젝트에서 가용 가능한 자원, 기술의 난이도, 사용하는 팀원을 고려한다면 Lambda는 적정기술이 아닐 수 있다.<br>
<!-- -->따라서 해당 이미지 생성기를 어떻게 적용할지 조금 더 고려를 해야 될 것으로 보인다.</p>
<p><strong>최종적으로 Java AWT를 사용하기로 결정했다.</strong></p>
<h2 id="참고-자료">참고 자료</h2>
<p><a href="https://aws.amazon.com/ko/lambda/">AWS Lambda</a><br>
<a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/configuration-layers.html">Lambda Layer</a><br>
<a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/python-package.html">Python Lambda 함수에 대한 .zip 파일 아카이브 작업</a><br>
<a href="https://gist.github.com/ksmin23/0f3f243408a8497f766b43cf589fea7b">No module named 'numpy.core._multiarray_umath'</a><br>
<a href="https://techblog.woowahan.com/6217/">사례별로 알아본 안전한 S3 사용 가이드</a></p>]]></content>
        <category label="Image" term="Image"/>
        <category label="Python" term="Python"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mockito 이용해서 static 메서드 모킹하기]]></title>
        <id>https://greeng00se.github.io/mock-static-method</id>
        <link href="https://greeng00se.github.io/mock-static-method"/>
        <updated>2023-07-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[개요]]></summary>
        <content type="html"><![CDATA[<h3 id="개요">개요</h3>
<p>정적 팩터리 메서드를 모킹한다는 것은 객체지향적인 관점에서 볼 때 안티패턴이다.<br>
<!-- -->하지만 특수한 경우에는 정적 메서드를 모킹하는 것이 필요할 수 있다고 생각한다.</p>
<p>예를 들어 레거시 코드를 테스트 한다던지, IO 관련한 부분을 테스트 할 때 정말 필요한 부분에만 적용할 수 있을 것이다.</p>
<p>프로젝트를 진행하며 ImageIo.write 메서드가 호출되는 지 검증이 필요했다.<br>
<!-- -->해당 static 메서드를 호출하는 부분을 따로 RouteImageUploader 클래스로 최대한 분리했다.<br>
<!-- -->이미지 저장 기능 자체가 외부로 나가는 상호작용이고, 호출 횟수를 검사하는데는 mock을 사용하는게 적절하다고 판단했다.</p>
<pre><code class="language-java">public void upload(BufferedImage bufferedImage) {
    File file = new File(파일경로);
    try {
        ImageIO.write(bufferedImage, ROUTE_IMAGE_FORMAT, file);
    } catch (IOException e) {
        throw new DrawException(IMAGE_SAVE_FAIL);
    }
}
</code></pre>
<h3 id="mocking-static-methods">Mocking static methods</h3>
<p>Mockito 3.4.0 이후에는 static method를 모킹할 수 있는 Mockito.mockStatic 메서드를 지원한다.<br>
<!-- -->mockStatic을 사용하면 <code>MockedStatic&lt;T&gt;</code>이 반환되는데 사용 후 꼭 close를 해줘야 한다.</p>
<p>JUnit의 @BeforeAll로 설정하고 @AfterAll 메서드로 종료하는 방법도 있지만 <code>MockedStatic&lt;T&gt;</code>의 상위 인터페이스인 ScopedMock이 AutoCloseable을 구현하고 있기에 try-with-resources를 사용하는 방법이 더욱 좋은 것 같다.</p>
<pre><code class="language-java">// given
BufferedImage bufferedImage = new BufferedImage(800, 800, BufferedImage.TYPE_INT_ARGB);
RouteImageUploader routeImageUploader = new RouteImageUploader();

// expect
try (MockedStatic&lt;ImageIO&gt; imageIO = Mockito.mockStatic(ImageIO.class)) {
    routeImageUploader.upload(bufferedImage);
    imageIO.verify(
            () -&gt; ImageIO.write(any(BufferedImage.class), any(String.class), any(File.class)),
            times(1)
    );
}
</code></pre>
<h3 id="마치며">마치며</h3>
<p>정적 메서드를 모킹하는 것은 안티패턴이으로 적절한 추상화를 이용해 테스트 하기 좋은 코드를 만드는 연습을 하자.<br>
<!-- -->하지만 추상화를 하면 할 수록 코드의 복잡도는 증가한다.<br>
<!-- -->항상 상황을 고려하고 간결함을 포기할 만큼 중요한 부분인지 적절한 트레이드오프를 고려하자.</p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#static_mocks">Mocking static methods</a><br>
<a href="https://www.baeldung.com/mockito-mock-static-methods">Mockito mock static methods</a><br>
<a href="https://github.com/mockito/mockito/issues/1013">Enable mocking static methods in Mockito</a></p>]]></content>
        <category label="Mockito" term="Mockito"/>
        <category label="static" term="static"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[경로 이미지 생성하기 - 기술 선택]]></title>
        <id>https://greeng00se.github.io/route-image-intro</id>
        <link href="https://greeng00se.github.io/route-image-intro"/>
        <updated>2023-07-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[./route.png]]></summary>
        <content type="html"><![CDATA[<p><img alt="./route.png" src="https://greeng00se.github.io/assets/images/route-89cacb9b7815a3191ab1f9d9e23c43a1.png" width="1014" height="902"></p>
<h3 id="이미지-생성의-책임">이미지 생성의 책임</h3>
<p>위 와이어 프레임에서 <code>여행 히스토리</code>와 <code>여행에 대한 감상을 위한 경로 이미지</code>의 경우 네이버 지도를 사용하여 해당 기능을 구현할 수 없으니 당연히 맵 API에서 제공하는 도형 그리기 API(네이버 맵 API 기준 Polyline)를 사용할 수 없다.<br>
<!-- -->따라서 이미지를 직접 생성하거나, 클라이언트에서 직접 위경도를 이용하여 그려야 한다.</p>
<p>해당 요구사항을 해결하기 위해서는 다음과 같은 기능을 가진 라이브러리가 필요하다.</p>
<ul>
<li>이미지 생성</li>
<li>선과 점 표현</li>
<li>투명한 배경색</li>
</ul>
<p>현재 클라이언트의 바쁜 일정과 기능 구현에 있어 약간의 연산이 들어간다는 부분을 고려하여 백엔드에서 이미지를 생성하기로 결정을 내렸다.</p>
<h3 id="고려한-기술">고려한 기술</h3>
<p>백엔드에서 이미지 생성을 하기 위해 다음과 같은 라이브러리 또는 기술들을 확인해 보았다.</p>
<ul>
<li>Python의 Matplotlib</li>
<li><strong>AWT(Abstract Window Toolkit) [최종 선택]</strong></li>
<li>이미지 처리 라이브러리 및 Java에서 내부적으로 Matplotlib 사용할 수 있는 라이브러리 (원하는 기능 없음)</li>
<li>Java Swing, Java FX (단순한 선 그리기 + 점 찍기라 불필요)</li>
</ul>
<h2 id="python--matplotlib">Python &amp; Matplotlib</h2>
<p>데이터 시각화 라이브러리<br>
<!-- -->이미지 생성 및 로컬에 저장까지 걸리는 시간: 0.2초</p>
<ul>
<li>코드가 간단해서 유지 보수성이 좋다.</li>
<li>AWS Lambda 같은 서버리스 컴퓨팅 서비스나 FastAPI와 같은 웹 프레임워크로 추가적인 API를 구현해야 한다.</li>
<li>Spring Boot에서 추가적인 API 호출을 해야하고, 확장성과 비동기 처리 등 고려 해야 할 부분이 많다.</li>
</ul>
<h3 id="java-awt-이외의-라이브러리">Java AWT 이외의 라이브러리</h3>
<p>Python이 아닌 Java에서의 라이브러리도 고려를 해봤지만 요구사항에 적합하지 않거나, 적은 요구사항에 비해 무거운 라이브러리들이 많아서 제외했다.</p>
<table><thead><tr><th>라이브러리</th><th>설명</th><th>제외 이유</th></tr></thead><tbody><tr><td>Swing</td><td>AWT 이후에 나온 GUI 라이브러리, 네이티브 UI를 사용하지 않고 모든 운영체제 상에서 동일한 UI를 가지도록 함</td><td>요구사항에 비해 무겁고 복잡도가 높음</td></tr><tr><td>JavaFX</td><td>Swing 이후에 나온 GUI 라이브러리, 3차원 그래픽을 지원함</td><td>요구사항에 비해 무겁고 복잡도가 높음</td></tr><tr><td><a href="https://github.com/yuriy-g/simple-java-plot">simple-java-plot</a></td><td>AWT로 구현된 플로팅 라이브러리</td><td>AWT 기반이긴 하지만 직접 AWT를 사용하는 것에 비해 메리트가 없음, 커스텀 설정 기능이 없음</td></tr><tr><td><a href="https://github.com/sh0nk/matplotlib4j">matplotlib4j</a></td><td>Matplotlib를 Java에서 사용할 수 있게 하는 라이브러리</td><td>내부적으로 파이썬 사용하기에 무거움, 배경 투명화 기능 없음</td></tr></tbody></table>
<h3 id="java--awtabstract-window-toolkit">Java &amp; AWT(Abstract Window Toolkit)</h3>
<p>그래픽과 이미지를 그리기 위한 도구<br>
<!-- -->이미지 생성 및 로컬에 저장까지 걸리는 시간: 1.75초</p>
<ul>
<li>플로팅 라이브러리를 사용하는 것보다 구현의 난이도가 다소 존재한다.</li>
<li>이미지 생성 시간이 다소 소요되기 때문에 빠른 응답 반환을 위해 비동기 처리를 고려할 수 있을 것 같다.</li>
<li>추가적인 api 호출을 하지 않아도 된다.</li>
</ul>
<h3 id="기술-선택">기술 선택</h3>
<p>AWT의 경우 Matplotlib에 비해 구현의 난이도가 다소 있고, 이미지 생성 시간이 더 많이 걸리는 단점이 있다.<br>
<!-- -->하지만 추가적인 api 호출을 하지 않아도 되는 부분, Python을 사용하는 경우 추가적인 웹 프레임워크의 학습 비용을 고려하여 AWT를 사용하기로 결정했다.</p>
<h3 id="유지-보수">유지 보수</h3>
<p>AWT라는 생소한 기술을 사용하기 때문에 유지 보수성을 위해 팀원들과 공유하는 것이 중요하다고 생각했다.<br>
<!-- -->따라서 다음과 같은 방법으로 공유하기로 했다.</p>
<ol>
<li>코드 리뷰와 PR을 통해 작성한 AWT 코드에 대한 설명 및 리뷰 받는다.</li>
<li>AWT를 사용한 부분을 문서화하여 공유한다.</li>
</ol>
<h3 id="레벨-3를-마무리하며-내용-추가">레벨 3를 마무리하며 내용 추가</h3>
<p>기술 선택을 하기 위한 실행 시간 측정에 오류가 있었다.<br>
<!-- -->AWT를 사용하는 부분에서 애플리케이션 실행 시간을 제외하면 파이썬과 비슷한 시간안에 이미지를 생성할 수 있었다.</p>]]></content>
        <category label="image" term="image"/>
        <category label="awt" term="awt"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[자바 17, 스프링 6.0, 스프링 부트 3.1]]></title>
        <id>https://greeng00se.github.io/java-spring-springboot</id>
        <link href="https://greeng00se.github.io/java-spring-springboot"/>
        <updated>2023-07-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[자바 17, 스프링 6.0, 스프링 부트 3.1]]></summary>
        <content type="html"><![CDATA[<h2 id="자바-17-스프링-60-스프링-부트-31">자바 17, 스프링 6.0, 스프링 부트 3.1</h2>
<p>팀 프로젝트를 진행하면서 스프링 부트 3.1을 사용하게 되었다.<br>
<!-- -->2.7 버전을 사용할 수도 있었지만 LTS 기간과 취약점 패치로 인한 버전업 등을 고려했을 때 3.1과 자바 17을 사용하는 것이 더 효율적이라고 판단했다.</p>
<h2 id="자바-변경-사항">자바 변경 사항</h2>
<p>우아한테크코스 레벨 2까지는 자바 11을 사용했었다.<br>
<!-- -->따라서 자바 11부터 자바 17까지의 변경사항을 정식 릴리즈 기준으로 정리해보려고 한다.</p>
<h3 id="switch-expressionsjava-14">Switch Expressions(Java 14)</h3>
<p>Java 14에서는 기존의 Switch 문을 간결하게 작성할 수 있는 Switch 식이 추가되었다.</p>
<pre><code class="language-java">enum RESULT {
    WIN, LOSE, DRAW
}

RESULT result = RESULT.WIN;

int prize = switch (result) {
    case WIN -&gt; 10_000_000;
    case LOSE, DRAW -&gt; 5_000_000;
	default -&gt; 0;
};
</code></pre>
<p>주요 특징은 다음과 같다.</p>
<ul>
<li><code>-&gt;</code> 연산자를 이용하여 각 case에 대한 결과를 바로 반환할 수 있다.</li>
<li>case를 콤마(<code>,</code>)로 연결하여 하나의 case에 여러 값을 지정할 수 있다.</li>
<li>break 문이 필요 없다.</li>
<li>default 블록을 통해 기본 값을 지정할 수 있다.</li>
</ul>
<h3 id="text-blockjava-15">Text Block(Java 15)</h3>
<p>Java 15에는 새로운 문자열 표현방식이 추가되었다.<br>
<!-- -->긴 문자열을 + 연산자의 도움 없이 가독성있게 작성할 수 있다.</p>
<pre><code class="language-java">@Repository
public interface PostRepository extends JpaRepository&lt;Post, Long&gt; {
    @Query("""
        SELECT p FROM Post p
        WHERE p.title LIKE %:keyword%
        OR p.content LIKE %:keyword%
        """)
    List&lt;Post&gt; findPostsByTitleOrContentContainingKeyword(String keyword);
}
</code></pre>
<h3 id="npe-메시지java-15">NPE 메시지(Java 15)</h3>
<pre><code class="language-java">String name = null;
name.chars();

/** 
# before
java.lang.NullPointerException
	at com.example.DiscountPolicyTest.test(NullPointerExceptionTest.java:61)

# after
Cannot invoke "String.chars()" because "name" is null
java.lang.NullPointerException: Cannot invoke "String.chars()" because "name" is null
*/
</code></pre>
<h3 id="recordjava-16">Record(Java 16)</h3>
<p>Lombok의 <code>@Data</code>, kotlin의 data 클래스와 유사한 기능을 제공한다.<br>
<!-- -->Record를 선언하는 경우 접근자, 생성자, equals &amp; hashcode, toString이 제공된다.<br>
<!-- -->데이터 전송 용도로 적합해 보인다.</p>
<pre><code class="language-java">public record PostDto(String title, String content) {
}
</code></pre>
<h3 id="추가적인-변경사항">추가적인 변경사항</h3>
<p>이외에도 stream의 toList, 인스턴스의 타입을 간편하게 체크하는 Pattern Matching Instanceof, Sealed class 등이 추가되었다.</p>
<h2 id="스프링-스프링-부트-변경-사항">스프링, 스프링 부트 변경 사항</h2>
<p>스프링과 스프링 부트에도 많은 변경 사항이 있었다.<br>
<!-- -->따라서 필요해보이는 몇개 정도만 정리했다.</p>
<h3 id="스프링-요구사항">스프링 요구사항</h3>
<p>Java 17, Jakarta EE 9 이상이어야 한다.</p>
<h3 id="네임스페이스-변경">네임스페이스 변경</h3>
<p>Jakarta EE 9가 적용되면서 네임스페이스도 전반적으로 javax -&gt; jakarta로 변경되었다.</p>
<h3 id="pathpatternparser---trailing-slash-허용하지-않음">PathPatternParser - trailing slash 허용하지 않음</h3>
<p>6.0 이전의 경우 기본 설정 기준으로 <code>@GetMapping("/hello")</code>와 <code>@GetMapping("/hello/")</code>가 동일했다.<br>
<!-- -->6.0 이후의 PathPatternParser가 기본으로 사용되고, <code>/hello</code>와 <code>/hello/</code>는 서로 다른 URL로 매칭된다.</p>
<blockquote>
<p>PathPatternParser used by default (with the ability to opt into PathMatcher).</p>
</blockquote>
<h3 id="http-interface-client">HTTP interface client</h3>
<p>자바 인터페이스와 어노테이션을 이용하여 HTTP 요청을 위한 서비스를 정의할 수 있는 방법이 추가되었다.<br>
<!-- -->자세한 내용은 <a href="https://www.youtube.com/watch?v=Kb37Q5GCyZs">토비님의 강의</a>를 참고하면 좋을 것 같다.</p>
<h3 id="스프링-부트-최소-요구사항">스프링 부트 최소 요구사항</h3>
<p>Gradle 7.3, Java 17, Kotlin 1.6, Jakarta EE 9, Spring Framework 6<br>
<!-- -->이외에도 서드파티들의 최신 릴리즈 버전을 사용함으로, 문제가 발생하는 경우 해당 버전에 맞는 릴리즈 노트를 참고할 수 있을 것 같다.</p>
<h2 id="참고-자료">참고 자료</h2>
<p><a href="https://www.youtube.com/watch?v=1WT6oxchM9M">어느&nbsp;월급쟁이개발자&nbsp;의 스프링 부트 따라잡기</a><br>
<a href="https://www.youtube.com/watch?v=7SlDdzVk6GE">자바 9-16 주요 특징 복습하기</a><br>
<a href="https://www.samsungsds.com/kr/insights/java_jakarta.html">Java EE에서 Jakarta EE로의 전환</a><br>
<a href="https://www.youtube.com/watch?v=Kb37Q5GCyZs">Spring 6의 새로운 HTTP Interface와 3 가지 REST Clients 라이브 코딩</a><br>
<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-6.x">What's New in Spring Framework 6.x</a><br>
<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">Spring Boot 3.0 Release Notes</a><br>
<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.1-Release-Notes">Spring Boot 3.1 Release Notes</a></p>]]></content>
        <category label="Java" term="Java"/>
        <category label="Spring Boot" term="Spring Boot"/>
        <category label="Spring" term="Spring"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[웹소켓]]></title>
        <id>https://greeng00se.github.io/websocket</id>
        <link href="https://greeng00se.github.io/websocket"/>
        <updated>2023-06-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[웹소켓]]></summary>
        <content type="html"><![CDATA[<h3 id="웹소켓">웹소켓</h3>
<p>단일 TCP 연결을 통해 클라이언트와 서버 간 전이중 양방향 통신을 지원하는 프로토콜<br>
<!-- -->웹 환경에서 연속된 데이터를 실시간으로 처리할 수 있다.</p>
<p>웹소켓은 HTTP의 포트를 그대로 사용하고 각각 포트 80과 포트 443을 사용하여 HTTP(ws://) 및 HTTPS(wss://)로 서버에 연결한다.</p>
<h3 id="웹소켓-등장-배경">웹소켓 등장 배경</h3>
<p>웹소켓이 등장하기 이전, 실시간성을 보장하기 위해 Polling, Long polling, Streaming 같은 기술을 사용했어야 했다.<br>
<!-- -->이는 실시간성이나 양방향성을 만족시키지 못했고, HTTP를 이용하기 때문에 과도한 오버헤드가 발생했다.</p>
<admonition title="polling, long polling, streaming" type="note"><p>Polling: 주기적으로 서버에 요청을 보내 수신할 정보가 있는지 확인하는 방법</p><ul>
<li>서버에서 보낼 내용이 없어도 클라이언트는 알 수 없다.</li>
<li>계속해서 요청을 보내 확인을 해야하기 때문에 서버에 불필요한 부하를 주어야 한다.</li>
</ul><p>Long Polling: 클라이언트의 요청에 대해 응답을 보내지 않고 있다가 이벤트가 발생했을때 응답하는 방법</p><ul>
<li>폴링 방식보다 서버에 적은 부하를 줄 수 있지만, 요청의 주기가 짧으면 폴링과 차이가 없어진다.</li>
</ul><p>Streaming: 클라이언트가 request를 보내면 커넥션을 맺고, 이 커넥션을 유지하면서 서버가 계속 데이터를 보내는 방법</p><ul>
<li>클라이언트가 서버에 요청을 하고 싶다면 새로운 커넥션을 맺어야 한다.</li>
</ul></admonition>
<h3 id="웹소켓의-동작">웹소켓의 동작</h3>
<mermaid value="sequenceDiagram
    participant Client
    participant Server
    Client->>Server: Handshake - Upgrade를 이용한 WebSocket 전환 요청
    Server->>Client: Handshake - HttpStatus 101(Switching Protocols)

    Client->>Server: 양방향 통신
    Server->>Client: 

    Client->>Server: 종료
    Server->>Client: "></mermaid>
<h3 id="1-upgrade-요청">1. Upgrade 요청</h3>
<p>WebSocket 프로토콜로 전환하는 HTTP 요청을 보낸다.<br>
<!-- -->이는 HTTP와 같이 80, 443 포트를 사용한다.<br>
<!-- -->웹소켓으로 전환하기 위해서는 Upgrade: websocket, Connection: Upgrade 헤더가 필요하다.<br>
<!-- -->Sec-WebSocket-Key는 서버에서 Sec-WebSocket-Accept를 계산하여 응답하고 이 값이 예상한 값과 다르면 연결이 수립되지 않는다.<br>
<!-- -->Sec-WebSocket-Protocol의 경우 서브프로토콜의 목록으로 서버 측에서는 해당 목록 중 하나를 선택하여 반환해야 한다.<br>
<!-- -->만약 서버측에서 여러 개 지원이 가능한 경우 지원 가능한 프로토콜 중 첫번째 프로토콜을 클라이언트측으로 보낸다.</p>
<pre><code>GET /chats HTTP/1.1
Host: localhost:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080
</code></pre>
<h3 id="2-switching-protocols">2. Switching Protocols</h3>
<p>서버는 101 Switching Protocols 응답을 반환한다.<br>
<!-- -->Sec-WebSocket-Accept은 Sec-WebSocket-Key 뒤에 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>를 붙이고 SHA1로 해싱 후 Base64로 인코딩하여 반환한다.<br>
<!-- -->이는 서버 웹소켓 프로토콜의 지원 여부를 클라이언트에게 명확히 알리기 위해 존재한다.</p>
<pre><code>HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
</code></pre>
<h3 id="3-통신-후-종료">3. 통신 후 종료</h3>
<p>연결이 수립되면 웹소켓 프레임 단위로 양방향 통신을 한다.<br>
<!-- -->연결 종료를 원하는 경우 클라이언트, 서버 모두 연결 종료를 요청할 수 있다.</p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc6455">https://datatracker.ietf.org/doc/html/rfc6455</a><br>
<a href="https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications">https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications</a><br>
<a href="https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</a><br>
<a href="https://docs.spring.io/spring-framework/reference/web/websocket.html">https://docs.spring.io/spring-framework/reference/web/websocket.html</a></p>]]></content>
        <category label="WebSocket" term="WebSocket"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docusaurus]]></title>
        <id>https://greeng00se.github.io/docusaurus</id>
        <link href="https://greeng00se.github.io/docusaurus"/>
        <updated>2023-06-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[팀 블로그 또는 문서화를 위해 Docusaurus를 사용하는 방법을 정리하려고 한다.]]></summary>
        <content type="html"><![CDATA[<p>팀 블로그 또는 문서화를 위해 Docusaurus를 사용하는 방법을 정리하려고 한다.</p>
<h2 id="설치">설치</h2>
<p><a href="https://docusaurus.io/docs/installation">공식 홈페이지</a>에 들어가서 최신 버전을 설치한다.</p>
<pre><code class="language-bash">yarn create docusaurus
</code></pre>
<h2 id="배포">배포</h2>
<p><a href="https://docusaurus.io/docs/next/deployment#deploying-to-github-pages">배포 안내 문서</a><br>
<!-- -->netlify나 vercel 같은 서버리스 플랫폼을 추천하고 있고, 간단하고, 빠른 시간 안에 배포를 할 수 있다.<br>
<!-- -->이 글에서는 github pages를 이용해서 배포하는 방법을 설명한다.</p>
<h3 id="레포지토리-생성">레포지토리 생성</h3>
<p>github pages를 이용하려면 <a href="https://github.com/greeng00se/greeng00se.github.io">예시</a>와 같이 <code>username.github.io</code> 형태의 레포지토리를 생성해야 한다.<br>
<!-- -->이때 organization을 사용하는 경우 <code>organization.github.io</code> 형태의 레포지토리를 생성해서 사용한다.</p>
<h3 id="설정-파일-수정">설정 파일 수정</h3>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">module.exports = {
  // ...
  url: 'https://greeng00se.github.io',
  baseUrl: '/',
  projectName: 'greeng00se.github.io',
  organizationName: 'greeng00se',
  trailingSlash: false,
  // ...
};
</code></pre>
<h3 id="토큰-설정">토큰 설정</h3>
<p>github action을 위해 배포용 토큰을 하나 생성하여 생성한 레포지토리에 Repository secrets으로 설정한다.<br>
<!-- -->이 글에서는 토큰을 클래식 방식으로 생성했고 스코프는 [repo, user, workflow] 을 설정했다.</p>
<p><img alt="github" src="https://greeng00se.github.io/assets/images/github-d866f69755a1e17d4f17a262bd30d56d.png" width="1598" height="1670"></p>
<h3 id="브랜치-생성">브랜치 생성</h3>
<p>github에서 gh-pages 브랜치를 하나 생성한다.<br>
<!-- -->repository -&gt; settings -&gt; pages -&gt; branch에서 생성한 gh-pages로 브랜치를 변경한다.<br>
<!-- -->설정한 브랜치가 배포 브랜치가 되며, 해당 브랜치에 있는 파일들을 이용해서 정적 웹사이트를 제공한다.</p>
<h3 id="워크플로-작성">워크플로 작성</h3>
<p>Docusaurus 2.0 기준 Node.js 16.14 이상의 버전을 사용해야 합니다.<br>
<!-- -->배포시에는 Repository secrets으로 설정한 DEPLOY_TOKEN 을 이용합니다.</p>
<pre><code class="language-yml" metastring="title=&quot;.github/workflows/deploy.yml&quot;">name: blog

on:
  push:
    branches: [main]

jobs:
  deploy:
    name: Deploy to GitHub Pages
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: yarn

      - name: Install dependencies
        run: yarn install --frozen-lockfile
      - name: Build website
        run: yarn build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.DEPLOY_TOKEN }}
          publish_dir: ./build
          user_name: github-actions[bot]
          user_email: 41898282+github-actions[bot]@users.noreply.github.com
</code></pre>
<h2 id="댓글-기능">댓글 기능</h2>
<p>giscus를 이용하여 댓글 기능을 추가한다.</p>
<h3 id="giscus-설정">giscus 설정</h3>
<ol>
<li>공개 저장소여야 한다.</li>
<li>giscus 앱이 설치되어 있어야 한다.</li>
<li>Discussions 기능이 해당 저장소에서 활성화되어 있어야 한다.</li>
</ol>
<p>자세한 내용은 <a href="https://giscus.app/ko">giscus</a>를 확인하자.</p>
<h3 id="docusaurus-설정">docusaurus 설정</h3>
<p><a href="https://docusaurus.io/ko/docs/next/swizzling">swizzling</a>을 이용하여 컴포넌트를 감싼다.<br>
<!-- -->기존에 게시물을 giscus가 포함된 리액트 컴포넌트로 감싸는 형태가 된다.<br>
<!-- -->아래 명령어를 이용하여 BlogPostItem을 추출할 수 있다.</p>
<pre><code class="language-bash">yarn run swizzle @docusaurus/theme-classic BlogPostItem -- --wrap
</code></pre>
<p>명령어를 입력하면 <code>/src/theme/BlogPostItem/index.js</code> 위치에 파일이 생성된다.<br>
<!-- -->파일의 내용을 아래와 같이 수정하고, 이때 setAttribute 부분은 적절하게 자신의 giscus 설정을 이용한다.</p>
<pre><code class="language-js" metastring="title=&quot;/src/theme/BlogPostItem/index.js&quot;">import OriginalBlogPostItem from "@theme-original/BlogPostItem";
import React, { useEffect, useRef } from "react";
// @ts-expect-error internal code
import { useColorMode } from "@docusaurus/theme-common";
import { useBlogPost } from "@docusaurus/theme-common/internal";

const giscusSelector = "iframe.giscus-frame";

function BlogPostItem(props) {
  const { colorMode } = useColorMode();
  const { isBlogPostPage } = useBlogPost();
  const giscusTheme = colorMode === "dark" ? "dark" : "light";
  const containerRef = useRef(null);

  useEffect(() =&gt; {
    if (!isBlogPostPage) return;

    const giscusEl = containerRef.current.querySelector(giscusSelector);

    const createGiscusEl = () =&gt; {
      const script = document.createElement("script");

      script.src = "https://giscus.app/client.js";
      script.setAttribute("data-repo", "teco-chat/teco-chat.github.io");
      script.setAttribute("data-repo-id", "R_kgDOJZ5j0Q");
      script.setAttribute("data-category", "Announcements");
      script.setAttribute("data-category-id", "DIC_kwDOJZ5j0c4CXS_Q");
      script.setAttribute("data-mapping", "pathname");
      script.setAttribute("data-strict", "0");
      script.setAttribute("data-reactions-enabled", "1");
      script.setAttribute("data-emit-metadata", "0");
      script.setAttribute("data-input-position", "bottom");
      script.setAttribute("data-theme", giscusTheme);
      script.setAttribute("data-lang", "ko");
      script.crossOrigin = "anonymous";
      script.async = true;
      
      containerRef.current.appendChild(script);
    };

    const postThemeMessage = () =&gt; {
      const message = {
        setConfig: {
          theme: giscusTheme,
        }
      };

      giscusEl.contentWindow.postMessage({ giscus: message }, "https://giscus.app");
    };

    giscusEl ? postThemeMessage() : createGiscusEl();
  }, [giscusTheme]);

  return (
    &lt;&gt;
      &lt;OriginalBlogPostItem {...props} /&gt;
      {isBlogPostPage &amp;&amp; &lt;div ref={containerRef} /&gt;}
    &lt;/&gt;
  );
}

export default BlogPostItem;
</code></pre>
<h2 id="알고리아-설정-및-직접-관리하기">알고리아 설정 및 직접 관리하기</h2>
<p>알고리아를 사용하면 검색 기능을 추가할 수 있다.<br>
<!-- -->유료 플랜이나 netlify를 사용하는 경우 크롤러를 따로 제공해 주는 것 같다.</p>
<p>무료 플랜은 직접 인덱스를 수집하는 방법과, <a href="https://docsearch.algolia.com/">docsearch</a>를 이용하는 방법이 있다.<br>
<!-- -->docsearch에 등록한다면 일주일에 한 번씩 크롤링이 진행된다.<br>
<!-- -->이 글에서는 직접 인덱스를 수집하는 방법을 사용한다.</p>
<ul>
<li><a href="https://docsearch.algolia.com/docs/legacy/run-your-own/">직접 인덱스 수집</a></li>
<li><a href="https://docsearch.algolia.com/docs/legacy/config-file">설정 파일</a></li>
</ul>
<h3 id="알고리아-애플리케이션-생성-및-키-확인">알고리아 애플리케이션 생성 및 키 확인</h3>
<p>회원가입을 하고 새로운 애플리케이션 생성을 누른다.<br>
<!-- -->생성을 다 마치면 다음과 같이 api 키를 확인할 수 있다.</p>
<p><img alt="algolia" src="https://greeng00se.github.io/assets/images/algolia-3dbac5c1606f7f0daed9cb27a429db50.png" width="3194" height="1520"></p>
<h3 id="키-생성">키 생성</h3>
<p>직접 인덱스를 수집하기 위한 키를 생성한다.<br>
<!-- -->addObject, editSettings, deleteIndex acl(접근 제어 목록)이 있으면 된다.</p>
<p><img alt="key" src="https://greeng00se.github.io/assets/images/key-2d0b59e69e9ca0b21c49b76159266e74.png" width="2496" height="832"></p>
<h3 id="env-파일-생성">.env 파일 생성</h3>
<p>프로젝트 폴더 상단에 .env 파일을 생성한다.</p>
<pre><code class="language-bash" metastring="title=&quot;.env&quot;">APPLICATION_ID=MVIU5UEMOM
API_KEY=인덱스_생성용_키
</code></pre>
<h3 id="config-파일-생성">config 파일 생성</h3>
<p>마찬가지로 최상단에 config.json 파일을 생성한다.
설정 파일은 해당 <a href="https://docsearch.algolia.com/docs/legacy/config-file">링크</a>를 참고한다.<br>
<!-- -->또는 Docusaurus의 <a href="https://github.com/algolia/docsearch-configs/blob/master/configs/docusaurus-2.json">설정 파일</a>을 참고한다.</p>
<pre><code class="language-json" metastring="title=&quot;config.json&quot;">{
  "index_name": "teco",
  "start_urls": [
    "https://teco-chat.github.io/"
  ],
  "sitemap_urls": [
    "https://teco-chat.github.io/sitemap.xml"
  ],
  "sitemap_alternate_links": true,
  "stop_urls": [
    "/tests"
  ],
  "selectors": {
    "lvl0": {
      "selector": "(//ul[contains(@class,'menu__list')]//a[contains(@class, 'menu__link menu__link--sublist menu__link--active')]/text() | //nav[contains(@class, 'navbar')]//a[contains(@class, 'navbar__link--active')]/text())[last()]",
      "type": "xpath",
      "global": true,
      "default_value": "Documentation"
    },
    "lvl1": "header h1",
    "lvl2": "article h2",
    "lvl3": "article h3",
    "lvl4": "article h4",
    "lvl5": "article h5, article td:first-child",
    "lvl6": "article h6",
    "text": "article p, article li, article td:last-child"
  },
  "strip_chars": " .,;:#",
  "custom_settings": {
    "separatorsToIndex": "_",
    "attributesForFaceting": [
      "language",
      "version",
      "type",
      "docusaurus_tag"
    ],
    "attributesToRetrieve": [
      "hierarchy",
      "content",
      "anchor",
      "url",
      "url_without_anchor",
      "type"
    ]
  },
  "conversation_id": [
    "833762294"
  ],
  "nb_hits": 46250
}
</code></pre>
<h3 id="docker-이용하여-크롤링">docker 이용하여 크롤링</h3>
<p>docker와 jq가 필요하다.<br>
<!-- -->jq가 설치되어 있지 않으면 mac 기준 brew를 이용해서 설치할 수 있다.</p>
<pre><code class="language-bash">brew install jq
</code></pre>
<p>다음 명령어를 이용하여 .env와 config.json을 이용하여 크롤링을 한다.</p>
<pre><code class="language-bash">docker run -it --env-file=.env -e "CONFIG=$(cat ./config.json | jq -r tostring)" algolia/docsearch-scraper
</code></pre>
<h3 id="docusaurus-설정-1">docusaurus 설정</h3>
<p>전에 확인한 APP ID, Search-Only API KEY, IndexName을 이용하여 docusaurus.config 파일에 설정한다.</p>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">themeConfig:
  /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
  ({
    ...
    algolia: {
      appId: 'MVIU5UEMOM', // Application ID
      apiKey: 'b68f378013817d9a190df88cdde226a0', // Search-Only API Key
      indexName: 'teco', // config.json에 설정한 인덱스명
      contextualSearch: true,
    },
  })
</code></pre>
<h2 id="부가-설정">부가 설정</h2>
<h3 id="화면-상단-github-icon">화면 상단 Github Icon</h3>
<p>파일 최하단에 아래 css 구문을 추가한다.</p>
<pre><code class="language-css" metastring="title=&quot;/src/css/custom.css&quot;">.header-github-link:hover {
  opacity: 0.6;
}

.header-github-link:before {
  content: '';
  width: 24px;
  height: 24px;
  display: flex;
  background: url("data:image/svg+xml,%3Csvg viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12'/%3E%3C/svg%3E")
    no-repeat;
}

html[data-theme='dark'] .header-github-link:before {
  background: url("data:image/svg+xml,%3Csvg viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12'/%3E%3C/svg%3E")
    no-repeat;
}
</code></pre>
<p>themeconfig -&gt; navbar에 github link를 설정한다.</p>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">navbar: {
  title: 'HELLO',
  items: [
    {
        href: 'https://github.com/greeng00se',
        position: 'right',
        className: 'header-github-link',
        'aria-label': 'GitHub repository',
    },
  ],
},
</code></pre>
<h3 id="코드블럭">코드블럭</h3>
<p>java나 kotlin의 경우 기본적으로 하이라이팅을 지원해 주지 않는다.<br>
<!-- -->prism 설정을 아래와 같이 변경해 준다.</p>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">prism: {
  theme: lightCodeTheme,
  darkTheme: darkCodeTheme,
  additionalLanguages: ['java', 'kotlin'],
}
</code></pre>
<h3 id="mermaid">mermaid</h3>
<p>mermaid를 사용하려면 <code>@docusaurus/theme-mermaid</code> 를 설치해야 한다.</p>
<pre><code class="language-bash">yarn add @docusaurus/theme-mermaid
</code></pre>
<p>설치 후 아래와 같이 설정을 추가한다.</p>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">const config = {
  ...
  markdown: {
    mermaid: true,
  },
  themes: [
    '@docusaurus/theme-mermaid'
  ],
};
</code></pre>
<p>themeConfig에서 mermaid의 테마를 지정할 수 있다.</p>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">themeConfig:
    /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
    ({
      ...
      mermaid: {
        theme: {
          light: 'neutral', 
          dark: 'dark'
        },
      },
    }),
</code></pre>
<h3 id="국제화-설정">국제화 설정</h3>
<p>국제화 설정을 한다면 <code>Older Entries</code> 형태의 설명이 <code>다음 페이지</code> 로 변경된다.<br>
<!-- -->설정파일에서 i18n에 있는 로케일 설정을 ko로 변경하면 된다.</p>
<pre><code class="language-js" metastring="title=&quot;docusaurus.config&quot;">i18n: {
  defaultLocale: "ko",
  locales: ["ko"],
},
</code></pre>
<h3 id="블로그-글-author">블로그 글 author</h3>
<p>팀원 별로 문서를 관리한다면 다음과 같이 어떤 팀원이 글을 작성했는지 설정해야 한다.</p>
<p><img alt="author" src="https://greeng00se.github.io/assets/images/author-1bd517bb7763257e2139e1063fd92492.png" width="2362" height="1076"></p>
<p><code>authors.yml</code> 파일을 이용하여 사용자에 대한 기본 설정을 할 수 있다.</p>
<pre><code class="language-yml" metastring="title=&quot;/blog/authors.yml&quot;">herb:
  name: 허브
  title: Backend
  url: https://github.com/greeng00se
  image_url: https://github.com/greeng00se.png

mallang:
  name: 말랑
  title: Backend
  url: https://github.com/shin-mallang
  image_url: https://github.com/shin-mallang.png
</code></pre>
<p>블로그 글을 작성할 때 다음과 같이 authors에 넣어주기만 하면 된다.</p>
<pre><code class="language-mdx">---
slug: 1
title: Hello World
authors: [herb, mallang]
tags: [hello, docusaurus]
---

첫 번째 문서 내용
</code></pre>]]></content>
        <category label="Documentation" term="Documentation"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[우아한테크코스 레벨 2 회고]]></title>
        <id>https://greeng00se.github.io/woowacourse-level2-retrospective</id>
        <link href="https://greeng00se.github.io/woowacourse-level2-retrospective"/>
        <updated>2023-06-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[23년의 6월이 오고, 레벨 2가 끝났다.]]></summary>
        <content type="html"><![CDATA[<p>23년의 6월이 오고, 레벨 2가 끝났다.<br>
<!-- -->빠르게 지나가서 조금 아쉽다.</p>
<h3 id="학습">학습</h3>
<p>회고를 작성하기 전에 레벨 2 동안 보냈던 PR과 회고를 쭉 읽어봤다.<br>
<!-- -->항상 아쉬운 곳은 있기 마련이지만, 잘 학습한 것 같다.<br>
<!-- -->미션을 하면서 기술을 어떻게 선택하고, 적용할 것인지 고민하는 과정에서 꽤나 많은 성장을 한 것 같다.</p>
<p>고민은 깊었지만 이론적인 학습이 부족한 레벨 2였다.<br>
<!-- -->방학 그리고 레벨 3 때는 조금 더 이론적인 부분을 학습하는데 집중해야겠다.</p>
<p>점차 학습 범위가 넓어지면서 자연스럽게 모르는 내용이 쌓여간다.<br>
<!-- -->필요한 내용은 앞으로 천천히 학습하면 되니까 조급해지지 말아야겠다.</p>
<h3 id="수면">수면</h3>
<p>레벨 2를 진행하는 동안 수면이 많이 부족했었고, 결과적으로는 그날의 컨디션을 많이 좌우했던 것 같다.<br>
<!-- -->앞으로 수면 시간을 늘리고, 좋은 수면 습관을 가지도록 노력해야겠다.</p>
<h3 id="협업">협업</h3>
<p>레벨 2 마지막에 협업 미션이 있었다.<br>
<!-- -->지금까지는 백엔드 크루들과 페어 프로그래밍을 하면서 협업을 경험했다.<br>
<!-- -->이번에는 프런트엔드 크루와 협업을 했다. 소통은 잘 된 것 같지만 API 명세를 정하는 부분이 아직 미숙한 것 같다.</p>
<p>레벨 3 때부터 본격적으로 프로젝트가 시작된다.<br>
<!-- -->팀을 위해 어떤 것을 할 수 있을지 고민을 많이 해봐야겠다.</p>
<h3 id="레벨-2를-마무리하며">레벨 2를 마무리하며</h3>
<p>회고 작성하면서 레벨 2에서 했던 것들을 반추해 봤는데 부족한 점은 많았어도 좋은 방향으로 가고 있는 것 같다.
읽고 싶은 책도 읽고, 부족한 부분 채우면서 쉬어야겠다.</p>]]></content>
        <category label="Woowahan Techcourse" term="Woowahan Techcourse"/>
        <category label="Retrospective" term="Retrospective"/>
    </entry>
</feed>